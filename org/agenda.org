#+title: Agenda Notebook
#+author: Marcus Birkenkrahe
#+subtitle: DSC 205 - Intro to Advanced Data Science - SP25
#+SEQ_TODO: TODO NEXT IN_PROGRESS | DONE CANCELLED
#+startup: overview hideblocks indent entitiespretty
#+property: :header-args:C:      :main yes :includes <stdio.h> :results output :exports both
#+property: :header-args:python: :session *Python* :python python3 :results output :exports both
#+property: :header-args:R  :session *R* :results output :exports both
#+property: :header-args:C++:    :main yes :includes <iostream> :results output :exports both
* DONE Week 1: Course overview & R Basics Test
#+attr_html: :width 400px
[[../img/cover.png]]

- [X] Course overview
- [X] On the DataCamp assignments
- [X] A brief review of R (followed by test 1 - until Thu 23-Jan)
- [ ] Calling functions: Scope and R environments

** DONE On DataCamp assignments

1. Watch the video first with full attention.
2. Write down immediate questions for later.
3. Build a notebook for DataCamp courses.
4. Recreate the individual steps in the video.
5. Create or import datasets.
6. Look up function definitions.
7. Solve the exercises outside of DataCamp.
8. If you loathe Emacs, use DataLab or Colab instead.
9. Don't ignore nagging questions that you have.
10. Start a journal to summarize what you've learnt.

** DONE Review

1. When are data Big Data?
   #+begin_quote
   3V: When they're either very large (volume > 1 PetaByte), coming in
   fast (velocity), or consist of multiple modes or media types
   (variety).
   #+end_quote

2. What does "DevOps" mean?
   #+begin_quote
   "Development Operations", frameworks that address the interface
   between IT operations and software developers.
   #+end_quote

3. What exactly does =sudo apt update -y && sudo apt upgrade -y= mean?
   #+begin_quote
   "As super-user, use the package manager program =apt= to =update= the
   list of installed software (don't ask me any questions, and then
   (provided the =update= process is complete), install the available
   =upgrade= software (again without asking me any questions).
   #+end_quote

4. Name at least one element of a "data science workflow"!
   #+begin_quote
   1) *Search* for data, e.g. with a search engine
   2) *Download* data, e.g. with =wget= on the command-line
   3) *Edit* code & documentation in a notebook, e.g. =.org= in Emacs
   4) *Run* scripts on the command-line using the =bash= shell program
   5) *Debug* scripts, e.g. using the GNU debugger =gdb=
   6) *Visualize* results, e.g. using R's =plot= function
   7) *Predict* trends, e.g. using R's =lm= regression model
   8) *Transform* data, e.g. using =log10= for base-10 logarithms
   9) *Delete* data, e.g. by redirecting errors to =/dev/null=
   10) *Model* data, e.g. by converting CSV data to a =data.frame=
   #+end_quote

5. What is *RStudio*?
   #+begin_quote
   RStudio is a popular integrated development environment (IDE) for R
   (and Python, with SQL) with notebook and publication capabilities.
   #+end_quote

6. What is the "Tidyverse"?
   #+begin_quote
   The "Tidyverse" is a collection of R packages including the popular
   =ggplot2= visualization package, and =dplyr= for =data.frame=
   manipulation. I don't like it but don't let me stop you from liking
   and using the "Tidyverse" packages: You can turn it into an
   interesting project, too! Hadley Wickham is a central figure for
   the "Tidyverse". He is also the author of the free "R in Action"
   textbook, of the original =ggplot2=, and of RStudio.
   #+end_quote

** DONE A brief review of R - 10 problems
#+attr_html: :width 400px:
[[../img/review.png]]

- *Download* the practice file: [[https://tinyurl.com/R-basics-org][tinyurl.com/R-basics-org]] on the
  command-line using =wget= or in Emacs using =eww=

- *Complete* the practice file: There are three short problems for each
  of R's data structures - numbers, vectors, matrices, data frames,
  factors, and lists.

- *Upload* your completed practice file to Canvas so that I can check
  your state of mind and mastery.

- *Review* the solutions in class.

- *Review* your own solutions depending on how you did in class.

* DONE Week 2: Scope and environment
#+attr_html: :width 400px:
#+caption: Nikolay Bogdanov-Belsky, Mental Arithmetic (1893)
[[../img/bogdanovbelskymentalarithmetic.jpg]]

- [X] R Basics practice: You need to train! What can I do?
- [X] *Test 1* (R Basics) is live - deadline: Friday 24-Jan (11:59 pm).
- [ ] Calling functions: *Scope* and R *environments*
- [ ] *Control flow*: DataCamp review (by Thursday 23-Jan, 11 am)

** DONE Scope and environments

- [X] Lecture: [[https://github.com/birkenkrahe/ds2-25/blob/main/org/2_scoping.org][See GitHub]]
- [X] Codealong: [[https://tinyurl.com/scoping-codealong-org][tinyurl.com/scoping-codealong-org]]
- [ ] Practice: [[https://tinyurl.com/scoping-practice-org][tinyurl.com/scoping-practice-org]]

** DONE DataCamp review: Control flow (9 problems)

I now longer trust that *showing* you solutions has any effect on your
learning skills. You need to *solve problems*, no matter how small. If
you don't do this on your own time, we'll do it in class.

Download and complete the practice file:
[[https://tinyurl.com/ds2-practice-2-org][tinyurl.com/ds2-practice-2-org]]

* DONE Week 3: Arguments
#+attr_html: :width 600px:
#+caption: St. Thomas Aquinas (1225-1274)
[[../img/aquinas.jpg]]

/What are humanity's most discussed questions throughout the ages?/
#+begin_quote
- Why are we here?
- What is the purpose of life?
- Is there a higher power or ultimate truth?
- What is the nature of good and evil?
#+end_quote

- [X] On the power of arguments (a philosophical distraction)
- [X] *Projects:* Enter your ideas now - sprint review: Fri 7-Feb
- [X] *Test 2* due Fri 31-Jan (100%) - available until Fri 7-Feb (50%)
- [X] *Caveat:* test includes all of the lecture content on "scoping"
- [X] *Review:* Plot test 1 grades [[https://tinyurl.com/scoping-review-org][tinyurl.com/scoping-review-org]]
- [X] *Lecture*: Scoping, environments, namespaces (continued)
- [X] *Practice:* [[https://tinyurl.com/scoping-practice-org][tinyurl.com/scoping-practice-org]]
- [X] *Lecture*: Arguments (GitHub) with practice (GitHub)

** Projects - sprint review coming soon
#+attr_html: :width 600px:
[[../img/projects.png]]

** Plot your test grades (future assignment)
#+attr_html: :width 400px:
[[../img/test_1_report.png]]

Don't let your plotting skills go to waste! When I see a plot like
this, I always want to recreate (and improve) it (if I can).

Let's do this together! Code along: [[https://tinyurl.com/scoping-review-org][tinyurl.com/scoping-review-org]]

** Current assignments

- New scoping review assignment (deadline Feb 7).
- Pushed DataCamp assignment to Friday 11:59 pm.
- Remember: 50% for a week after the deadline, 0% thereafter.
- Project proposal deadline coming up (Feb 7).
- You can do it on your own or in a team (we'll make it work).

** Scoping practice (lab)

- *Practice* file: [[https://tinyurl.com/scoping-practice-org][tinyurl.com/scoping-practice-org]]
- Upload the result to Canvas

** Function arguments (lecture & practice)

- Download the code along file: [[https://tinyurl.com/arguments-code-along][tinyurl.com/arguments-code-along]]
- Save it as an Org-mode file
- Code along with me during the lecture.

* DONE Week 4: Conditionals & Sprint review

- [X] Test 2 results & extended deadline (50%)
- [X] Review home assignment
- [ ] *Review:* Loops in R & function arguments
- [ ] *Test 3* due by Tuesday Feb 11 (extended deadline Friday Feb 14)
- [ ] Lecture & practice: =if= =else= =ifelse=
- [ ] In-class practice: =if= =else= =ifelse=
- [ ] Home assignment: =if= =else= =ifelse= - until Friday 14 Feb
- [X] Project revue: Briefly explain your idea(s)

** Test 2 results are excellent!
#+attr_html: :width 400px:
[[../img/test2_results.png]]

- A few missed the deadline & the extended deadline for test 1: 0 pts!
- A few missed the deadline for test 2, too: complete it for 50% by Friday!
- Use Canvas/Google Calendar to stay on top of your assignments!

** Home assignment: Scoping & Environments

Some students asked for a reminder. See also solution PDF in GitHub.

1. How would you put this code into an R script?
   #+begin_example R
   hist(Nile)
   #+end_example
   #+begin_src R :tangle histNile.R
     hist(Nile)  # tangle with C-c C-v t (org-babel-tangle)
   #+end_src

2. How would you check that a script exists without leaving R?
   #+begin_src bash :results output :exports both
     ls -l *.R  # on the CLI use the `ls` command
   #+end_src
   #+begin_src R :results output
     system("ls -l *.R*")   # shell() on Windoze
   #+end_src

   #+RESULTS:
   : -rw-rw-r-- 1 marcus marcus 55 Feb  4 11:11 histNile.R
   : -rw-rw-r-- 1 marcus marcus 11 Feb  4 11:10 hN.R

3. How can you run the script on the command-line?
   #+begin_src bash :results output :exports both
     Rscript histNile.R
   #+end_src
   #+begin_src R :results output
     system("Rscript histNile.R")
     system("ls -l *R*")
   #+end_src

   #+RESULTS:
   : -rw-rw-r-- 1 marcus marcus   55 Feb  4 11:11 histNile.R
   : -rw-rw-r-- 1 marcus marcus   11 Feb  4 11:10 hN.R
   : -rw-rw-r-- 1 marcus marcus 4609 Feb  4 11:15 Rplots.pdf

4. What is the output of the script?
   #+begin_src R :results output
     system("file R*") # Rscript produces R* files
     system("evince Rplots.pdf")  # evince is a Linux PDF viewer app
   #+end_src

   #+RESULTS:
   : Rplots.pdf: PDF document, version 1.4, 1 pages

   This is what we do when we use notebooks in class:
   #+begin_src R :file histNile.png :results output graphics file :exports both :comments both :tangle yes :noweb yes
     hist(Nile)
   #+end_src

   #+RESULTS:
   [[file:histNile.png]]

5. What is the other way to run R scripts on the command-line?
   #+begin_src R :results output
     system("R CMD BATCH histNile.R")
     system("ls -l *.R* R*")
     system("cat histNile.Rout")
   #+end_src

   #+RESULTS:
   #+begin_example
   -rw-rw-r-- 1 marcus marcus   55 Feb  4 11:11 histNile.R
   -rw-rw-r-- 1 marcus marcus  811 Feb  4 11:19 histNile.Rout
   -rw-rw-r-- 1 marcus marcus   11 Feb  4 11:10 hN.R
   -rw-rw-r-- 1 marcus marcus 4609 Feb  4 11:19 Rplots.pdf

   R version 4.1.2 (2021-11-01) -- "Bird Hippie"
   Copyright (C) 2021 The R Foundation for Statistical Computing
   Platform: x86_64-pc-linux-gnu (64-bit)

   R is free software and comes with ABSOLUTELY NO WARRANTY.
   You are welcome to redistribute it under certain conditions.
   Type 'license()' or 'licence()' for distribution details.

     Natural language support but running in an English locale

   R is a collaborative project with many contributors.
   Type 'contributors()' for more information and
   'citation()' on how to cite R or R packages in publications.

   Type 'demo()' for some demos, 'help()' for on-line help, or
   'help.start()' for an HTML browser interface to help.
   Type 'q()' to quit R.

   > hist(Nile)  # tangle with C-c C-v t (org-babel-tangle)
   >
   > proc.time()
      user  system elapsed
     0.108   0.017   0.116
   #+end_example

** Review & Practice: Arguments / Loops

1) Is ~matrix~ elliptic?
   #+begin_src R :results output
     args(matrix) # not elliptic - no ellipsis arguments f(par1, par2,...)
   #+end_src

   #+RESULTS:
   : function (data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL)
   : NULL

2) Use positional matching with ~seq~ to create a sequence of values
   between -4 and 4 that progresses in steps of 0.2.
   #+begin_src R :results output
     seq(-4,4,0.2)
     args(seq)
   #+end_src

   #+RESULTS:
   :  [1] -4.0 -3.8 -3.6 -3.4 -3.2 -3.0 -2.8 -2.6 -2.4 -2.2 -2.0 -1.8 -1.6 -1.4 -1.2
   : [16] -1.0 -0.8 -0.6 -0.4 -0.2  0.0  0.2  0.4  0.6  0.8  1.0  1.2  1.4  1.6  1.8
   : [31]  2.0  2.2  2.4  2.6  2.8  3.0  3.2  3.4  3.6  3.8  4.0
   : function (...)
   : NULL

3) Identify, which style of argument matching is being used:
   exact, partial, positional, or mixed. If mixed, which arguments are
   specified?

   1. ~array~
      #+begin_src R :results output
        array(8:1,dim=c(2,2,2)) # mixed, `data` is positional
      #+end_src

      #+RESULTS:
      #+begin_example
      , , 1

           [,1] [,2]
      [1,]    8    6
      [2,]    7    5

      , , 2

           [,1] [,2]
      [1,]    4    2
      [2,]    3    1

      #+end_example

   2. ~rep~
      #+begin_src R :results output
        rep(1:2,3) # positional
      #+end_src

      #+RESULTS:
      : [1] 1 2 1 2 1 2

   3. ~seq~
      #+begin_src R :results output
        seq(from=10,to=8,length=5) # exact
      #+end_src

   4. ~sort~
      #+begin_src R :results output
        sort(decreasing=T,x=c(2,1,1,2,0.3,3,1.3)) # exact
      #+end_src

   5. ~which~ (1)
      #+begin_src R :results output
        matrix(c(T,F,T,T),2,2)
        which(matrix(c(T,F,T,T),2,2)) # positional
      #+end_src

      #+RESULTS:
      :       [,1] [,2]
      : [1,]  TRUE TRUE
      : [2,] FALSE TRUE
      : [1] 1 3 4

   6. ~which~ (2)
      #+begin_src R :results output
        which(matrix(c(T,F,T,T),2,2),a=T) # mixed
        args(which)
      #+end_src

      #+RESULTS:
      :      row col
      : [1,]   1   1
      : [2,]   1   2
      : [3,]   2   2
      : function (x, arr.ind = FALSE, useNames = TRUE)
      : NULL

4) What is the key difference between a =for= loop and a =while= loop?
   #+begin_quote
   A =for= loop iterates over a predefined sequence, such as a vector
   or list, and executes the loop body once for each element.

   A =while= loop, on the other hand, continues executing as long as a
   specified condition remains =TRUE=, making it useful for situations
   where the number of iterations is not known in advance.
   #+end_quote

5) What are the advantages and disadvantages of using a =for= loop
   instead of a =while= loop in R?

   #+begin_quote
   *Advantages:*
   - A =for= loop is generally more readable and requires fewer lines of
     code when iterating over a known sequence.
   - It reduces the risk of infinite loops since the iteration count
     is predetermined.
   - It is easier to debug because the loop boundaries are explicitly
     defined.

   *Disadvantages:*
   - A =for= loop is less flexible when the number of iterations is not
     known in advance.
   - If the sequence length changes dynamically within the loop, a =for=
     loop may not behave as expected.
   - It can be less efficient when iterating over large datasets
     compared to vectorized solutions.
   #+end_quote

6) Write a =for= and a =while= loop that prints the numbers 1 to 5.
   #+begin_src R :session *R* :results output :exports both
     for (i in 1:5)
       print(i)

     i <- 1
     while(i<=5) {
       print(i)
       i <- i + 1
     }
   #+end_src

   #+RESULTS:
   #+begin_example
   [1] 1
   [1] 2
   [1] 3
   [1] 4
   [1] 5
   [1] 1
   [1] 2
   [1] 3
   [1] 4
   [1] 5
   #+end_example

7) Modify the loops to print the numbers as part of a vector like so:
   #+begin_example
     [1] 1 2 3 4 5
   #+end_example

   #+begin_src R :session *R* :results output :exports both
     foo <- c() # alternative: vector()
     foo
     for (i in 1:5)
       foo[i] <- i
     foo

     bar <- c()
     i <- 1
     while(i<=5) {
       bar[i] <- i
       i <- i + 1
     }
     bar
   #+end_src

   #+RESULTS:
   : NULL
   : [1] 1 2 3 4 5
   : [1] 1 2 3 4 5

   #+begin_src R :session *R* :results output :exports both
     foo <- c()
     for (i in 1:5) {
       foo[i] <- i
     }
     foo

     bar <- c()
     i <- 1
     while(i<=5) {
       bar[i] <- i
       i <- i + 1
     }
     bar
   #+end_src

8) Write a =for= loop that prints each element of a vector, where the
   vector’s length is unknown in advance. Example vector:
   =c("Joe","Jim","Jane","Jack","Jill")=

   #+BEGIN_SRC R :results output
     values <- c("Joe","Jim","Jane","Jack","Jill")  # could be any length

     for (i in 1:length(values)) {
       print(values[i])
     }
   #+END_SRC

   #+RESULTS:
   : [1] "Joe"
   : [1] "Jim"
   : [1] "Jane"
   : [1] "Jack"
   : [1] "Jill"

9) Write a =while= loop that processes a Boolean vector, stopping as
   soon as it encounters the first =FALSE= value, when the length of the
   vector is not known. Example vector: c(TRUE, TRUE, TRUE, FALSE,
   TRUE, TRUE)

   #+begin_src R :results output
     flags <- c(TRUE, TRUE, TRUE, FALSE, TRUE, TRUE)
     i <- 1 # initialize index for loop

     while(i <= length(flags) && flags[i]) { # FALSE when both conditions are FALSE
       print(flags[i])
       i <- i + 1
     }
   #+end_src

   #+RESULTS:
   : [1] TRUE
   : [1] TRUE
   : [1] TRUE

   #+BEGIN_SRC R :results output
     flags <- c(TRUE, TRUE, TRUE, FALSE, TRUE, TRUE)  # Boolean vector
     i <- 1  # Initialize index

     while (i <= length(flags) && flags[i]) { # TRUE if both are TRUE
       print(paste("Processing element", i))
       i <- i + 1  # Increment index
     }
   #+END_SRC

10) Consider the following R code, explain step by step what this loop
    does, and determine the output.
    #+BEGIN_SRC R :results output
      vec <- c(5, 2, 9, 0, 3, 8, 7)
      i <- 1

      while (i <= length(vec)) {
        if (vec[i] == 0) {
          print("Zero encountered! Stopping loop.")
          break
        } else if (vec[i] %% 2 == 0) {
          i <- i + 1
          next
        }
        print(vec[i])
        i <- i + 1
      }
    #+END_SRC

    #+RESULTS:
    : [1] 5
    : [1] 9
    : [1] "Zero encountered! Stopping loop."

    #+begin_quote
    *Step-by-step execution:*
    - The loop starts with =i = 1= and checks if =vec[i] == 0=.
    - If =vec[i]= is =0=, it prints ="Zero encountered! Stopping loop."= and
      exits (=break=).
    - If =vec[i]= is even, the =next= statement skips printing and moves to the next iteration.
    - Otherwise, it prints =vec[i]= and increments =i=.

    *Tracing the execution:*
    - =vec[1] = 5= → odd, so =print(5)=, increment =i= to 2.
    - =vec[2] = 2= → even, so =next= skips printing, increment =i= to 3.
    - =vec[3] = 9= → odd, so =print(9)=, increment =i= to 4.
    - =vec[4] = 0= → =break= triggers, prints ="Zero encountered! Stopping
      loop."= and exits.
    #+end_quote

* DONE Week 5: Nested If & Switch & function review
#+attr_html: :width 600px:
#+caption: Francisco de Goya, Still Life with Golden Bream (1808)
[[../img/goya.jpg]]

- [X] *Test 3* available only until tonight (max. 100%)
- [ ] *Practice* (with upload): =if=-=else=-=ifelse=
- [ ] *Programming assignment*: Conditional statements
- [ ] *DataCamp review*: Functions (next test)
- [ ] *Lecture & Practice*: =switch= function

** Project proposal submissions

- Everybody submitted on time (never happened before)
- You should add your project to the Canvas pages
- You should put your submission into GDrive
- You should submit the URL to Canvas (1 per team)
- I will view/grade the submissions later this week
- The next sprint review is a *"Literature review"*
- *What does this mean?* (Details in Canvas later)
  1) *Understand* HOW you could continue your project.
  2) *Review* other people's stuff (scholarly papers preferred).
  3) *Deliver* either a =notebooklm= or a literature review

** DataCamp Review - Functions

1. What does the =na.rm= argument in =mean(x, na.rm = FALSE)= do?
   #+BEGIN_QUOTE
   It determines whether missing (=NA=) values should be removed before
   computation. When =FALSE=, =NA= values cause the result to be =NA=.
   #+END_QUOTE

2. Can you construct an example showing this?
   #+begin_src R :results output
     mean(c(1,2,3,NA))   # `na.rm = FALSE` is the default
     mean(c(1,2,3,NA),na.rm=TRUE)
   #+end_src

   #+RESULTS:
   : [1] NA
   : [1] 2

3. What is wrong with this code, and how would you fix it?
   #+begin_src R :results output :exports both
     function(x) {
       3 * x
     }
     ls()
   #+end_src

   #+RESULTS:
   : function (x)
   : {
   :     3 * x
   : }
   : character(0)

   #+begin_quote
   There is nothing wrong with the code as such but the function is
   not stored in an object (check with =ls()=) and cannot be used.
   #+end_quote
   #+begin_src R :session *R* :results output :exports both
     triple <- function(x) {
       3 * x
     }
     ls()
   #+end_src

   #+RESULTS:
   : [1] "triple"

4. Which of these function calls will work on this function?
   #+begin_src R :session *R* :results output :exports both
     triple(3)
     triple(y=3)
     triple(x=3)
     triple()
   #+end_src

   #+RESULTS:
   : [1] 9
   : Error in triple(y = 3) : unused argument (y = 3)
   : [1] 9
   : Error in triple() : argument "x" is missing, with no default

   #+begin_src R :session *R* :results output :exports both
     triple
     args(triple)
   #+end_src

   #+RESULTS:
   : function(x) {
   :   3 * x
   : }
   : <bytecode: 0x564099882540>
   : function (x)
   : NULL

5. What does the "black box principle" mean in the context of functions?
   #+BEGIN_QUOTE
   It means that functions take inputs, process them internally, and
   return outputs without the user needing to understand the internal
   workings. However, you can, and should, still try to analyze them!
   #+END_QUOTE

6. What happens when =ls= is called without an argument? What happens
   when =mean= is called without an argument?
   #+begin_src R :session *R* :results output :exports both
     ls()  # returns objects in the current environment
     mean()  # computes arithmetic average
     args(mean)  # shows that `x` (or 1st arg) is needed
   #+end_src

   #+RESULTS:
   : [1] "triple"
   : Error in mean.default() : argument "x" is missing, with no default
   : function (x, ...)
   : NULL

   #+begin_src R :session *R* :results output :exports both
     ls
   #+end_src

   #+RESULTS:
   #+begin_example
   function (name, pos = -1L, envir = as.environment(pos), all.names = FALSE,
       pattern, sorted = TRUE)
   {
       if (!missing(name)) {
           pos <- tryCatch(name, error = function(e) e)
           if (inherits(pos, "error")) {
               name <- substitute(name)
               if (!is.character(name))
                   name <- deparse(name)
               warning(gettextf("%s converted to character string",
                   sQuote(name)), domain = NA)
               pos <- name
           }
       }
       all.names <- .Internal(ls(envir, all.names, sorted))
       if (!missing(pattern)) {
           if ((ll <- length(grep("[", pattern, fixed = TRUE))) &&
               ll != length(grep("]", pattern, fixed = TRUE))) {
               if (pattern == "[") {
                   pattern <- "\\["
                   warning("replaced regular expression pattern '[' by  '\\\\['")
               }
               else if (length(grep("[^\\\\]\\[<-", pattern))) {
                   pattern <- sub("\\[<-", "\\\\\\[<-", pattern)
                   warning("replaced '[<-' by '\\\\[<-' in regular expression pattern")
               }
           }
           grep(pattern, all.names, value = TRUE)
       }
       else all.names
   }
   <bytecode: 0x564097f07818>
   <environment: namespace:base>
   #+end_example

   #+begin_quote
   - =ls= is a utility function that retrieves object names from an
     environment. If there is no name, it returns an empty =character=
     vector.
   - =mean= is a mathematical function expecting =numeric= input
   #+end_quote

   #+begin_src R :results output
     environment(ls)
   #+end_src

   #+RESULTS:
   : <environment: namespace:base>

7. What is the difference between =return(y)= and simply writing =y= at
   the end of an R function?
   #+BEGIN_QUOTE
   Both return the value, but using =return(y)= explicitly specifies the
   return value.
   #+END_QUOTE

8. What will happen if you call =math_magic(4)= when
   #+begin_example
     math_magic <- function(a, b) { a * b + a / b }
   #+end_example
   #+BEGIN_QUOTE
   It will result in an error because argument =b= is missing and has no
   default.
   #+END_QUOTE

9. How can you define an optional argument in an R function?
   #+BEGIN_QUOTE
   By assigning a default value: =math_magic <- function(a, b = 1)=.
   #+END_QUOTE

10. What is the difference between =library("ggvis")= and =require("ggvis")=?
    #+BEGIN_QUOTE
    =library("ggvis")= throws an error if the package is not installed,
    while =require("ggvis")= returns =FALSE= instead of an error.
    #+END_QUOTE

** Home assignment (by Monday 17 Feb) - Canvas

- The final code is short (<10 lines) but packs a punch
- You need functions =which=, =diag=, =matrix=, =substr=, and =if=, =else=
- You need to plan your approach using pseudocode
- Your submission should be a *literate program* (like your project)
- What does that mean?
  1) The submitted file is created for humans to read it (and not just
     for machines to run it).
  2) Some *documentation* that clarifies the approach (list of steps),
     the logic (like pseudocode).
  3) *Code* should be in blocks, (minimally) commented, indented (readable).
  4) *Output:* Not arbitrary but as requested ("test suite" must pass).
  5) *Meta data*: file header, purpose, author, pledge

** In-class assignment conditional statements (Canvas upload)

- Download the raw exercise file from [[https://tinyurl.com/R-ifelse-practice][tinyurl.com/R-ifelse-practice]]

- Save and complete it, and upload your solution to Canvas:
  =Classroom Assignments > Conditionals practice.=

** Review =ifelse=

1. What is the reason to use =ifelse= and what does it do?
   #+begin_quote
   From =help(ifelse)=: =ifelse(test, yes, no)=

   =ifelse= returns a value with the same shape as =test= which is filled
   with elements selected from either =yes= or =no= depending on whether
   the element of =test= is ~TRUE~ or ~FALSE~.
   #+end_quote

2. What does this code produce?
   #+begin_src R :session *R* :results output :exports both
     mat <- diag(2)
     ifelse(test=mat > 0,
            yes="High",
            no="Low")
   #+end_src

   #+RESULTS:
   :      [,1]   [,2]
   : [1,] "High" "Low"
   : [2,] "Low"  "High"

   #+begin_quote
   - The shape of =mat= is a 2 x 2 matrix. =ifelse= returns such a matrix.
   - The ~1~ values (=yes=) are filled with ~"High"~.
   - The ~0~ values (=no=) are filled with ~"Low"~.
   #+end_quote

3. Let =foo <- c(192,168,1,1)= and =bar <- c(192,168,1,2)=. I want to
   compare the two vectors to check if the first two elements are the
   same. Will the following code do that or not?

   #+begin_src R :session *R* :results output :exports both
     foo <- c(192,168,1,1)
     bar <- c(192,168,1,2)

     ifelse(
       test = (foo[1:2]==bar[1:2]),
       yes  = cat("Same subnet\n"),
       no   = cat("Not same subnet\n"))
   #+end_src

   #+RESULTS:
   : Same subnet
   : Error in ans[ypos] <- rep(yes, length.out = len)[ypos] :
   :   replacement has length zero
   : In addition: Warning message:
   : In rep(yes, length.out = len) : 'x' is NULL so the result will be NULL

   #+begin_src R :session *R* :results output :exports both
     foo <- c(192,168,1,1) # IP = 192.168.1.1
     bar <- c(192,168,1,2) # IP = 192.168.1.2

     if (all(foo[1:2] == bar[1:2])) {
       cat("Same subnet\n")
     } else {
       cat("Not same subnet\n")
     }
   #+end_src

   #+RESULTS:
   : Same subnet

4. Make the =ifelse= statement explicit (by converting it to code with
   =for= and =if= and =else=?
   #+begin_src R :results output
     foo <- c(192,168,1,1)
     bar <- c(192,168,1,2)

     ifelse(foo==bar,  # check if the two vectors are identical
            yes=TRUE,  # returns TRUE as a vector element
            no=FALSE)  # returns FALSE as a vector element
   #+end_src

   #+RESULTS:
   : [1]  TRUE  TRUE  TRUE FALSE

   Solution:
   #+name: comparison
   #+begin_src R :session *R* :results output :exports both
     for (i in 1:length(foo)) {
       if(foo[i]==bar[i]) {
         print(TRUE)
       } else {
         print(FALSE)
       }
     }
   #+end_src

   #+RESULTS: comparison
   : [1] TRUE
   : [1] TRUE
   : [1] TRUE
   : [1] FALSE

5. Turn the last program into a function =ip= that is called on =foo= and
   =bar= and returns the Boolean values.
   #+begin_src R :tangle ip.R :session *R* :results output :exports both :noweb yes
     ## function definition
     ip <- function(foo,bar) {
       <<comparison>>      # this is noweb (insert `comparison` block
     }
     ## function call
     ip(foo,bar)
   #+end_src

   #+RESULTS:
   : [1] TRUE
   : [1] TRUE
   : [1] TRUE
   : [1] FALSE

* DONE Week 6: Practice nested if, switch & Loops

- [X] *Test 4* is live - max 100% (50%) until Feb 21 (28).
- [X] *Practice:* ~switch~ and nested ~if~ review practice
- [X] *Lecture / Codealong / Practice review:* ~for~ loops

* DONE Week 7: Even more loops - ~for~ a[nd] ~while~
#+attr_html: :width 400px :float nil:
[[../img/picasso.jpg]]

- [X] *Tests & Assignments*: Removing 1 point per late day. Easier for
  me, kinder to you. All close one week after the deadline though.

- [X] *Unprecedented:* This course has 100% on time DataCamp completion!
  Therefore, I'll assign the next course *as a whole* by April 1.

- [X] *Review* ~for~ loop.

- [X] *Bonus* programming assignment in Canvas.

- [X] *Finish* lecture: nested ~for~ loops.

- [X] *Test 5* coming up later this week (available only until March 11)

- [X] *Download* and *complete* review exercises & upload solution:
  [[https://tinyurl.com/for-loop-practice][tinyurl.com/for-loop-practice]] - we will review results in class.

- [ ] *DataCamp* assignment ("Utilities") *deadline moved* to Monday.

** =for= loop review (aka test preview) questions

1. What is the primary difference between a ~for~ loop and a ~while~
   loop in R (actually all ALGOL-like languages, C, Java, Python...)?

   #+begin_quote
   A ~for~ loop iterates over a predefined sequence (e.g., a vector),
   whereas a ~while~ loop continues executing as long as a specified
   condition remains =TRUE=.
   #+end_quote

2. Given the following ~for~ loop, what will be the output?

   #+begin_src R :results output
     for (i in c(2, 4, 6)) { # looping over vectorx
       print(i^2)
     }
   #+end_src

   #+RESULTS:
   : [1] 4
   : [1] 16
   : [1] 36

3. How does the ~apply~ function differ from traditional loops in R?

   #+begin_quote
   The ~apply~ function applies a function to elements of an array,
   (matrix, or dataframe) without explicitly writing a loop, making
   code more concise and often improving performance.
   #+end_quote

4. How would you compute the average of =c(1:10,NA)= using ~apply~?

   #+begin_src R :results output
     sapply(X=list(c(1:10,NA)),
            FUN=mean,
            na.rm=TRUE)
   #+end_src

   #+RESULTS:
   : [1] 5.5

   #+begin_src R :results output
     lapply(X=list(c(1:10,NA)),
            FUN=mean,
            na.rm=TRUE) |> unlist()
   #+end_src

   #+RESULTS:
   : [1] 5.5

5. What is the difference between looping over a vector’s values
   versus looping over its indices?

   #+begin_quote
   Both approaches produce the same output, but looping over indices
   provides greater flexibility, such as modifying vector elements
   inside the loop.
   #+end_quote

6. Loop over a) values, b) indices of =myvec <- c(0.4, 1.1, 0.34, 0.55)=
   and print the vector values.

   #+begin_src R :results output
     myvec <- c(0.4, 1.1, 0.34, 0.55)

                                             # Looping over values directly
     for (i in myvec) {
       print(i)
     }

                                             # Looping over indices
     for (i in 1:length(myvec)) {
       print(myvec[i])
     }
   #+end_src

   #+RESULTS:
   : [1] 0.4
   : [1] 1.1
   : [1] 0.34
   : [1] 0.55
   : [1] 0.4
   : [1] 1.1
   : [1] 0.34
   : [1] 0.55

7. How can you print the previous results as a vector like this:
   #+begin_example
   [1] 0.8 2.2 0.68 1.1
   #+end_example

   #+begin_src R :results output
     myvec <- c(0.4, 1.1, 0.34, 0.55)
     result <- NA  # initialize a generalized data structure

     ## Looping over indices
     for (i in 1:length(myvec)) {
       result[i] <- myvec[i]       # cast result as a vector
     }
     result
   #+end_src

   #+RESULTS:

   Pythonistas: This the same issue as printing a list vs. printing a
   list "comprehension".

8. Why does ~class(element)~ not work correctly when determining the
   data type of matrix elements in a list?

   #+begin_quote
   The ~class(element)~ function returns the type of the entire object
   rather than the data type of its contents. To retrieve the data
   type of matrix elements, use ~class(as.vector(element))~ instead.
   #+end_quote

   #+begin_src R :results output
     mylist <- list("hello",
                    matrix(1:4,nrow=2))
     ## loop over the values of myvec
     for (i in mylist) {
       print(class(i))   # which objects does mylist contain?
     }
   #+end_src

   #+RESULTS:
   : [1] "character"
   : [1] "matrix" "array"

   Can you show this?
   #+begin_src R :results output
     mylist <- list("hello", matrix(1:4,nrow=2))
     ## loop over the values of mylist
     for (i in mylist) {
       print(paste("Object class:",class(i)))
     }
     ## loop over the values of mylist again
     for (i in mylist) {
       print(paste("Object class:",class(as.vector(i))))
     }
   #+end_src

   #+RESULTS:
   : [1] "Object class: character"
   : [1] "Object class: matrix" "Object class: array"
   : [1] "Object class: character"
   : [1] "Object class: integer"

9. What will be the output of the following ~for~ loop?

   #+begin_src R :results output
     for (i in 1:3) {
       cat("Iteration:", i,"\n")  # cat is different from print!
     }
   #+end_src

   #+RESULTS:
   : Iteration: 1
   : Iteration: 2
   : Iteration: 3

10. What about this ~for~ loop?

    #+begin_src R :results output
      for (i in 1:3) {
        print(paste("Iteration:", i)) # `paste` coerces to `character`
      }
    #+end_src

    #+RESULTS:
    : [1] "Iteration: 1"
    : [1] "Iteration: 2"
    : [1] "Iteration: 3"

11. How can you modify the following ~for~ loop to print both the index
    and value of each element in ~myvec~?

    #+begin_src R :results output
      myvec <- c("A", "B", "C")

      ## loop over the values of myvec
      for (i in myvec) {
        print(i)
      }
    #+end_src

    *Solution:*
    #+begin_src R :results output
      myvec <- c("A", "B", "C")

                                              # Use indexing to print both the index and value
      for (i in 1:length(myvec)) {   # index looping
        cat("Index:", i, "Value:", myvec[i], "\n")
      }
    #+end_src

12. What happens when ~length(myvec)~ is used in a ~for~ loop but ~myvec~ is
    an empty vector?

    #+begin_src R :results output
      myvec <- c()
      for (i in 1:length(myvec)) {
        print(i)
      }
    #+end_src

    #+RESULTS:
    : [1] 1
    : [1] 0

    #+begin_quote
    =1:length(myvec)= is =1:0=, leading to two iterations.
    #+end_quote

13. How can you avoid looping over an empty vector?
    #+begin_quote
    Check if the vector is empty before looping:
    #+end_quote
    #+begin_src R :results output
      myvec <- c()
      if (length(myvec) > 0) {
        for (i in 1:length(myvec)) {
          print(i)
        }
      } else {
        cat("Vector is empty.\n")
      }
    #+end_src

    #+RESULTS:
    : Vector is empty.

** Project review - Issues and Tips

1) What is the central purpose of a project proposal?

   - Create an outline and think through your project
   - Describe your project to someone who has no clue
   - Check if you're on the right track before you bomb

   #+begin_quote
   To get buy-in from the project sponsor (that's me). Prove to him
   that this is something worth spending some time on. Sell a product:
   You + your work, to solve a problem within the framework of the
   project.
   #+end_quote

2) What's the purpose of a sprint review?

   - Evaluate results, identify good, bad, ugly
   - Split the total project time up into sprints
   - Show off your prototype (what you have so far)

   #+begin_quote
   To present your progress (or lack thereof) to the project owner or
   sponsor, and to the other projects, to highlight issues, enter in a
   conversation with the project owner, and to identify the steps for
   the next sprint. This last step was not asked (I should have -
   let's do it now).
   #+end_quote

3) How much time should you put into the project per week?
   #+begin_quote
   The syllabus does not mention the project separately (too hard to
   do the accounting), but it says: You should spend no less than 25
   minutes per day on this course (outside of class), or no less than
   2.5 hours per week. I spend at least 1 hour per day per class (or >
   4 hours per day). If you have 5-6 classes, you should spend 3-4
   hours per day studying for them.

   Within that schedule, at least 1 hour (10 min per day) should go
   towards your project - in practice more like 1/2 day every 2
   weeks - for a total of no less than 24-32 hours (3-4 days).

   Many proposals look as if you spent too little time on the
   proposals. Reading and working through references alone takes time.
   #+end_quote

4) What is the specific purpose of the project in this course?
   #+begin_quote
   To study, play with, and explain technology - in particular data
   science packages of functions and datasets, in the context of
   applying them to real problems.

   Most of you only talk about the problem but not about the
   tools. You don't even cite them. You need to combine your
   tool-based and your topical research (and plan on doing that).

   This is quite a different approach from what you're used to in
   class, but it is quite close to what you'll be doing in the field.
   #+end_quote

5) What are inline references and what are they good for?
   #+begin_quote
   Inline references are abbreviated references that need to be
   written out fully in the reference section. They back up claims
   that made in the text that are non-trivial and not generally known
   to be true.

   Examples:
   - "Agents are not typically taught..."
   - "This approach is common..."
   - "It is pointless to try to..."
   - "Datasets are not publicly available..."

   If you don't need inline references, you make no non-trivial
   claims, which could mean that you're not specific enough or that
   you have not researched the background of your problem.
   #+end_quote

6) What is AMA citation and did you use a consistent style?
   #+begin_quote
   An AMA citation refers to the citation style outlined in the
   American Medical Association (AMA) Manual of Style, which is
   commonly used in medicine, healthcare, and biological sciences. The
   AMA citation style follows a numbered system where references are
   listed in the order they appear in the text.

   Examples:
   - [Journal Paper] Smith J, Doe A. Neural networks and phase
     transitions. J Comput Neurosci. 2023;45(2):123-135.
     doi:10.1001/jcn.2023.456
   - [Book] Bishop CM. Pattern Recognition and Machine
     Learning. Springer; 2006.
   - [Website] National Institutes of Health. Artificial intelligence
     in medicine. NIH. Published January 10, 2024. Accessed February
     25, 2025. https://www.nih.gov/ai-medicine
   - [Conf Paper] Johnson K, Lee R. Category theory in neural network
     phase transitions. In: Proceedings of the AI & Math Conference;
     2024; New York, NY. Springer; 2024:210-225.
   - Other things: blog, software, video, etc.

   Who used AMA? I noticed a lot of inconsistencies, and unncecessary
   URLs etc. Many more references than ever (!) but often in shambles.
   #+end_quote

7) How informal should a proposal be? How subjective in tone?
   #+begin_quote
   You need to balance personal, practical and professional tone in
   anything you write to anyone for school or business. How much
   depends totally on the audience and the problem.

   There is only one hard rule for project documentation (and for
   publication in general): Personal/subjective remarks need to have a
   place of their own, and they must not bleed into the
   professional/practical documentation. Otherwise you spoil your
   professional appearance, and you make it very hard for anyone
   except whom you were thinking of to understand what's going on.

   A technical document (e.g. for a TV) has NO personal text, while a
   entertaining novel (e.g. Pride and Prejudice) has NO professional
   text. A research paper should have a mixture of both types of text.
   #+end_quote

8) Do you need references? Which ones, and why?
   #+begin_quote
   The only situation where you don't need any references is when you
   are working on something that nobody has ever worked on so that
   your choice of topic and method are completely original.

   So you do need them. As many scientific ones (peer-reviewed) as
   possible. You must make an assessment of the validity of your
   sources, and you need to be able to answer for them.
   #+end_quote

9) Do you have to improve your proposal based on the feedback?
   #+begin_quote
   Yes, you should, and you should touch base with me if anything in
   the feedback is unclear. The feedback should be more formal than it
   is - basically I'm only checking if you fulfilled the requirements
   to the letter (e.g. completeness, consistent references etc.)
   and/or in spirit, if it's doable, and if you've done everything you
   could at this point.

   A formal feedback would require a formal list of weighted criteria
   (a rubric). This is what you'll be facing in business not
   academia. Academia is terribly weak this way and much less
   resilient - you can see this in the science funding drama that is
   currently unfolding around us: scientists often don't bother
   justifying their ends, especially if they feel justified by their
   means.

   I don't bother with a formal framework mainly because otherwise I
   would have to spend a lot more time on the projects (like a manager
   would whose main job is managing projects, pennies, and people). So
   this is your show and responsibility much more than it would be in
   the real world.

   Do you have to share your improved proposal with me, unasked?
   Absolutely, if you've got any doubts if you did it right, or if you
   just want to show off a good piece of work (that's never wrong -
   you may want a letter of reference from me one day). This shows
   both diligence and resilience.
   #+end_quote

10) Should you look at the proposals of others?
    #+begin_quote
    Absolutely. Cristian's proposals are the most polished ones. In
    DSC 305, Matthew's proposal has the most meat (data sets and code
    examples attached). Donna's proposal reflects the greatest range
    of ambitions. Gavin's and Isaac's proposals are pithy and to the
    point. Fowler's proposals are fairly personal.

    You should make up your own mind about these. They're all
    interesting, and they all have slight issues here and there.

    You might even give the authors tips based on your experience or
    your views.
    #+end_quote

11) Do you need an AI disclaimer?
    #+begin_quote
    It would be good! Matthew designed one that I asked the AI to
    rewrite and I think it worked quite well (Ariel also had something
    like this in his proposal):

    "In researching for this project, I may have been exposed to
    AI-generated content in search results and news feeds. However, I
    affirm that this work is my own and was completed with academic
    integrity, without relying on AI to circumvent my responsibilities
    as a student."

    If you don't have a disclaimer because you used AI directly, you
    needed to (and still need to) document as much as possible
    (including perhaps by sharing links to your conversation) why and
    how you used the AI.
    #+end_quote

** Summary of my experiences

1) What is NotebookLM? See [[https://notebooklm.google][notebooklm.google]].
   #+begin_quote
   - Personalized AI Research Assistant.
   - Multimodal sources can be fed into it.
   - Expert in the information that you've given it.
   - Provides citations based on your sources.
   - Provides engaging Deep Dive discussions between two hosts.
   - Does not use your personal data and sources for training.
   #+end_quote

2) The first experiment: Uploaded a proposal that I wrote quickly,
   with some broad resources that I had collected over the past weeks.

3) The chat summarized my goals and approaches for me and linked the
   output back to the text.

4) I uploaded some hefty sources (almost 1000 pages of material),
   papers, a book.

5) Consequently, the sources were used in the chat when I asked about
   the state of the art in my areas of interest.

6) At the bottom of the screen, the AI suggests questions, some of
   which are good.

7) I saved interesting answers as notes for later.

8) The notebook conversation never goes outside of the frame defined
   by your proposal and the sources (unlike ChatGPT).

9) Wrote a minimal proposal without references admitting my ignorance
   about the topics, and uploaded it.

10) Asked the AI what to do next: The AI will not go beyond what you
    told it = a minimal proposal is not sufficient to proceed with the
    research.

11) Without any additional sources, generated a "Deep Dive
    conversation" to see if it yields any insights or ideas (5.5 min).
    - Defines the terms (easier for AI because it's about AI) - What.
    - Identifies a motivation for the research - What.
    - Talks about the methods - How.
    - The goals/deliverables (in the context of the research).
    - Recap is accurate and uplifting.
    - Distracting question: Could this teach us something about how
      our own brains work - what if our creativity is a biological
      version of hallucinations (that's one theory). Is hallucinating
      AI on the cusp of becoming conscious? Looking into the mind of a
      machine to understand our own minds?

12) Went to the other (richer, sourced) notebook, defined a focus that
    interests me (understanding and modeling hallucinations) and
    generated a podcast (12.5 min) - a few good insights and
    questions leading to new papers and connections between ideas.

13) The podcast is useful: It reveals both depth and lack of depth. It
    inspires but this inspiration is very high level and useless
    unless you buckle down and do the work that the AI is hinting at.

** Today: Begin (or continue) your Literature Review

You can skip the first two steps if you don't have at least one
scientific paper yet. Instead, use the notebook to identify one.

1) Open/register/login to litmaps.com.

2) Create a litmap of a relevant scholarly article OR put your project
   topic in the search field to identify potentially relevant papers.

   #+attr_html: :width 400px
   [[../img/litmap.png]]

   This might help you find new stuff.
   #+attr_html: :width 600px
   [[../img/category.png]]

3) Open NotebookLM by Google and create a new notebook.

4) Upload your proposal in its present form. Before you go on, check
   in the =Chat= in NotebookLM the summary and the questions.

5) In the =Chat= ask a question that you actuall have related to your
   project.

6) Upload any other source that you already know.

7) In the =Chat=, questions relevant to the proposal are being
   asked. Start a conversation and use prompts to channel it into
   something useful to improve your proposal.

   The AI answers are linked to parts of your proposal document. If
   the proposal is very thin on the ground, or unclear, it'll show.

   #+attr_html: :width 400px
   [[../img/notebooklm.png]]

8) Upload my feedback and ask in the =Chat= for clarification or changes
   to the proposal. Ask for what the next steps could be.

9) Fix your proposal accordingly.

10) Upload an improved proposal.

11) Rinse and repeat the =Chat= exercise until you've got no more
    questions.

12) Create the (first) podcast.

* DONE Week 8: Utilities & ~while~ loops
#+attr_html: :width 400px :float nil:
#+caption: Piet Lastman, Jonah and the Whale (1621)
[[../img/jonah.jpg]]

- [X] Sample solutions
- [X] ~while~ loops - lecture & codealong & exercise
- [X] Test 5 on loops, project, utilities - deadline March 18
- [X] ~apply~ functions - lecture & codealong & exercise

- [X] 25% not bothering with non-DataCamp assignments.
- [X] There's a new assignment - =Titanic= with ~tapply~
- [X] I will post a couple of (simple) bonus assignments.

- [X] Fake papers & the literature review
- [X] DataCamp review: Utilities & apply
- [ ] Loops finisher: ~break,~ ~next,~ ~repeat~

** Sample solutions for programming assignments

I will grade these later in the week. You should then compare with the
online sample solutions.

- [[https://github.com/birkenkrahe/ds2-25/blob/main/org/conditional_statements.org][Conditional statements]] (see Canvas)
- [[https://github.com/birkenkrahe/ds2-25/blob/main/org/7_switch_exercise_solution.org][Nested conditionals and switch]] (see Canvas)

** ~while~ loops - lecture & codealong

- Download and complete: [[https://tinyurl.com/while-code-along][tinyurl.com/while-code-along]].
- Exercise: [[https://tinyurl.com/while-assignment][tinyurl.com/while-assignment]] (due March 13)

** ~apply~ functions - lecture & codealong

- Download and complete: [[https://tinyurl.com/apply-code-along][tinyurl.com/apply-code-along]].
- Exercise: [[https://tinyurl.com/apply-assignment][tinyurl.com/apply-assignment]] (due March 18)

** Literature Review: Fake Papers and the Sokal Hoax

- Post with specific hints on uncovering fake papers in the chat
  ([[https://blog.litmaps.com/p/have-you-cited-a-fake-paper-heres][Litmap]])

- Apart from the obvious (fake citations), it's hard for you to do.

- "Fake" does not just mean "made up": all research is made up to some
  extent - when evidence is collected, a methodology is used, which
  may be so flawed that the research findings are completely wrong.

- "Fake" may also mean "in bad faith" (cutting corners, or
  intellectually dishonest). This is an issue in the humanities.

- The first person to cover this phenomenon with great effect was Alan
  Sokal, a physics professor from NYU ([[https://physics.nyu.edu/sokal/weinberg.html][Weinberg, 1996]]) with
  "Transgressing the boundaries - Toward a transformative hermeneutics
  of quantum gravity" ([[https://physics.nyu.edu/sokal/transgress_v2/transgress_v2_singlefile.html][1995]]).

- [[https://www.theatlantic.com/ideas/archive/2018/10/new-sokal-hoax/572212/][In a more recent example (2018)]], three researchers faked 20 papers
  in fashionable disciplines ("gender studies", "queer studies", "fat
  studies"), of which only 30% were rejected.

- What do we learn from this?
  #+begin_quote
  1. Fake papers go beyond fabrication.
  2. Ideological alignment must not go over scientific validity.
  3. There is a tension between academic freedom and accountability.
  #+end_quote

- What can you do about it with regard to your research project?
  #+begin_quote
  1. Keep the topic - your research question - small and specific.
  2. Limit your sources to well validated sources (many citations,
     clear writing).
  3. Know your few sources well (research them!)
  4. Value primary data (that you take) above all else, and pay
     special attention to the origin of your secondary data.
  5. Consider alternate methodologies and have good reasons why you
     pick one way of doing things (not just "because I could").
  6. Don't be too sure, don't publish prematurely, and show your work
     to many (trustworthy) people for feedback.
  #+end_quote

** Review (test preview): DataCamp Intermediate R - Utilities

Fire up Emacs + Org-mode. There's some coding to do.

1. What does the =abs()= function do in R when applied to a vector like
   =v1 <- c(1.1, -7.1, 5.4, -2.7)=?
   #+BEGIN_QUOTE
   It returns the absolute values of the elements: =c(1.1, 7.1, 5.4,
   2.7)=.
   #+END_QUOTE
   #+begin_src R :session *R* :results output :exports both
     v1 <- c(1.1, -7.1, 5.4, -2.7)
     abs(v1)
   #+end_src

2. Write a function =is.pos= that checks if the argument is positive by
   printing 1 or 0 for every element that's positive (not positive),
   and check it with =v1= and =abs(v1)=. Use ~ifelse~.

   #+begin_src R :session *R* :results output :exports both
     is.pos <- function(x) {ifelse(test=(x>0), yes=1, no=0)}
     is.pos(abs(v1))
     is.pos(v1)
   #+end_src

3. Do the same thing as before but now use a ~for~ loop over the
   argument for a function =is.pos_for=.

   #+begin_src R :session *R* :results output :exports both
     ## loop over vector indices
     is.pos_for <- function(x) {
       for (i in 1:length(x)) {
         if(x[i]>0) print(1)
         else print (0)}
     }
     is.pos_for(abs(v1))
     is.pos_for(v1)
     ## loop over vector elements
     is.pos_for2 <- function(x) {
       for (element in x) {
         if(element>0) print(1)
         else print (0)}
     }
     is.pos_for2(abs(v1))
     is.pos_for2(v1)
   #+end_src

   #+RESULTS:
   #+begin_example
   [1] 1
   [1] 1
   [1] 1
   [1] 1
   [1] 1
   [1] 0
   [1] 1
   [1] 0
   [1] 1
   [1] 1
   [1] 1
   [1] 1
   [1] 1
   [1] 0
   [1] 1
   [1] 0
   #+end_example

4. Do the same thing yet again, but now use an ~apply~ function.

   #+begin_src R :session *R* :results output :exports both
     sapply(X=v1,FUN=function(x) { if(x>0) 1 else 0 })

     ## using `print` inside the anonymous function prints x first.
   #+end_src

   #+RESULTS:
   : [1] 1 0 1 0

5. How does the =round()= function behave when rounding the vector
   =c(1.1, 7.1, 5.4, 2.7)=?
   #+BEGIN_QUOTE
   It rounds each element to the nearest integer: =c(1, 7, 5, 3)=.
   #+END_QUOTE

   #+begin_src R :session *R* :results output :exports both
     round(c(1.1, 7.1, 5.4, 2.7))
   #+end_src

6. What is the result of =mean(c(sum(c(1, 2, 3)), sum(c(0, 0, 6))))=?
   #+BEGIN_QUOTE
   The result is =6=.
   #+END_QUOTE
   #+begin_src R :session *R* :results output :exports both
     sum(c(1, 2, 3)) # 6
     sum(c(0, 0, 6)) # 6
     c(sum(c(1, 2, 3)), sum(c(0, 0, 6))) # c(6,6)
     mean(c(sum(c(1, 2, 3)), sum(c(0, 0, 6)))) # (6 + 6) / 2 = 12 / 2 = 6
   #+end_src

7. What does the =seq()= function produce when you run =seq(8, 2, by = -2)=?
   #+BEGIN_QUOTE
   It generates a sequence: =c(8, 6, 4, 2)= - stepping backwards.
   #+END_QUOTE
   #+begin_src R :session *R* :results output :exports both
     seq(from=8, to=2, by=-2)
   #+end_src

8. What is the output of =sort(rep(seq(8, 2, by = -2), times = 2))=?
   #+BEGIN_QUOTE
   It returns =c(2, 2, 4, 4, 6, 6, 8, 8)=.

   1) =seq(8, 2, by = -2)= gives =c(8, 6, 4, 2)=
   2) =rep(..., times = 2)= repeats it to =c(8, 6, 4, 2, 8, 6, 4, 2)=
   3) =sort()= orders it to  =c(2, 2, 4, 4, 6, 6, 8, 8)=.
   #+END_QUOTE

   #+begin_src R :session *R* :results output :exports both
     seq(8, 2, by = -2) # 8 6 4 2
     rep(seq(8, 2, by = -2), times = 2) # 8 6 4 2 8 6 4 2
     sort(rep(seq(8, 2, by = -2), times = 2)) # 2 2 4 4 6 6 8 8
   #+end_src

9. How does =rep(c(8, 6, 4, 2), each = 2)= differ from =rep(c(8, 6, 4,
   2), times = 2)=?
   #+BEGIN_QUOTE
   - =rep(..., each = 2)= repeats each element twice before moving on
   - =rep(..., times = 2)= repeats the entire vector twice
   #+END_QUOTE

   #+begin_src R :session *R* :results output :exports both
     rep(c(8, 6, 4, 2), each = 2)
     rep(c(8, 6, 4, 2), times = 2)
   #+end_src

10. What does the =str()= function reveal about the structure of
    #+begin_src R :session *R* :results none
      li <- list(log = TRUE,
                 ch = "hello",
                 int_vec = sort(rep(seq(8, 2, by = -2), times = 2)))
    #+end_src

    #+begin_src R :session *R* :results output :exports both
      str(li) # `log` is logical, `ch` is a string, `int_vec` is numeric
    #+end_src

11. What is the result of =unlist(li)= for the list defined in the last question?
    #+BEGIN_QUOTE
    It flattens the list into a character vector.
    #+END_QUOTE

    #+begin_src R :session *R* :results output :exports both
      unlist(li)
    #+end_src

12. How do you create a date object in R for May 14, 1971, and what does it return?

    #+begin_src R :session *R* :results output :exports both
      class("1971-05-14")
      my_date <- as.Date("1971-05-14")
      my_date
      class(my_date)
    #+end_src

13. What happens when you add =1= to a POSIXct object like =my_time <-
    as.POSIXct("1971-05-14 11:25:15")=? And what happens when you
    ~unclass~ the object?
    #+BEGIN_QUOTE
    It adds 1 second, resulting in ="1971-05-14 11:25:16 CET"=.
    #+END_QUOTE

    #+begin_src R :session *R* :results output :exports both
      my_time <-  as.POSIXct("1971-05-14 11:25:15")
      my_time + 1
      as.numeric(unclass(my_time)) # seconds since epoch
      ## days since epoch on 3-March 202
      as.numeric(unclass(as.POSIXct("2025-03-03 00:00:00"))/(365*24*3600))
    #+end_src

14. What does 'POSIXct' mean?
    #+begin_quote
    POSIXct stands for "Portable Operating System Interface, calendar
    time". It is a class used in R to represent dates and times,
    stored internally as the number of seconds since the "Unix epoch",
    January 1, 1970, 00:00:00 UTC [French: Temps Universel Coordoné].
    #+end_quote

15. What does =Sys.Date= do, and what does this code return?
    #+begin_src R :session *R* :results output :exports both
      Sys.Date()  # current system date
      as.integer(as.Date("2025-05-09") - Sys.Date())  # returns 303
    #+end_src

    #+begin_quote
    - =Sys.Date= is the current date fetched via C's time functions
    - Return value is the number of days left until end of term!
    - =Sys.time= returns the date and time
    #+end_quote

16. Does POSIXct require a lot of work from R?

    Let's C:
    #+begin_src C
      #include <sys/time.h>  // For gettimeofday()
      #include <time.h>      // For time_t and localtime()

      struct timeval tv;   // tv has epoch time in seconds & microseconds
      struct tm *timeinfo;

      // Get the current time with `gettimeofday()`
      if (gettimeofday(&tv, NULL) == -1) {
        perror("gettimeofday failed");
        return 1;
       }

      // Convert seconds since epoch to local time
      timeinfo = localtime(&tv.tv_sec);
      if (timeinfo == NULL) {
        perror("localtime failed");
        return 1;
       }

      // Buffer to hold formatted time string
      char buffer[26];
      strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M:%S", timeinfo);

      // Print time with microseconds
      printf("Current time: %s.%06ld %s\n",
             buffer,
             tv.tv_usec,
             timeinfo->tm_zone);
    #+end_src

    Minimal (with way less control & less information):
    #+begin_src C
      #include <time.h>      // For time_t and ctime()
      // get address-of compound literal `time_t` initialized at epoch 0
      printf("%s\n",ctime(&(time_t){time(NULL)}));
    #+end_src

17. What does the following function do and what does it output?
    #+begin_src R :session *R* :results output :exports both
      wd <- function(date_str) {weekdays(as.Date(date_str))}
      date_str = "2025-03-03"
      wd(date_str)
    #+end_src

    #+begin_quote
    - =date_str= is a string formatted as a date ("YYYY-MM-DD")
    - =as.Date(data_str)= converts the string into a ~Date~ object.
    - ~weekdays~ extracts parts of a date from a ~Date~ object.
    #+end_quote

18. What does this code output?
    #+begin_src R :session *R* :results output :exports both
      animals <- c("cat", "dog", "caterpillar", "bird", "catfish")
      grep("cat", animals)
    #+end_src

    #+begin_quote
    =grep= extracts the pattern of its first argument from its second
    argument and returns the indices of its hits: =1 3 5=.
    #+end_quote

19. What does this code output?
    #+BEGIN_SRC R :results output
      words <- c("apple", "banana", "cat")
      sub("a", "X", words)
    #+END_SRC

    #+begin_quote
    ~sub~ replaces the first occurrence of ="a"= with ="X"= in each string
    of a ~character~ vector: ="Xpple"  "bXnana" "cXt"=.
    #+end_quote

20. What's the difference between ~grep~ and ~grepl~, ~sub~ and ~gsub~?
    #+BEGIN_QUOTE
    - ~grep~ vs. ~grepl~:
      - ~grep~: Returns the *indices* of elements in a vector that match a
        pattern (e.g., =grep("cat", c("cat", "dog"))= → =[1] 1=).
      - ~grepl~: Returns a *logical vector* indicating which elements
        match (e.g., =grepl("cat", c("cat", "dog"))= → =[1] TRUE FALSE=).

    - ~sub~ vs. ~gsub~:
      - ~sub~: Replaces the *first occurrence* of a pattern in each string
        (e.g., =sub("a", "X", "banana")= → ="bXnana"=).
      - ~gsub~: Replaces *all occurrences* of a pattern (e.g., =gsub("a",
        "X", "banana")= → ="bXnXnX"=).
    #+END_QUOTE

** When are ~rep~ and ~sort~ commutative?

- [[https://chat.google.com/room/AAAAIVNZUqA/7QrooQtzlc8/7QrooQtzlc8?cls=10][Link to the Google Chat message]]

- Chris Burris asked an interesting question about the association of
  ~sort~ and ~rep~ - here are some experiments. sort is mathematically
  idempotent (~sort(sort(x)) = sort(x)~, ~rep~ clearly is not but because
  ~sort~ has this property, you can do this: the sorted repetition is
  the same as a sorted repetition of the sorted vector.
  #+begin_src R :session *R* :results output :exports both
    seq(from=10,to=1,by=-2) -> toSort
    sort(toSort)
    sort(rep(toSort,2))
    rep(sort(toSort),2)
    sort(rep(sort(toSort),2))
  #+end_src

  #+RESULTS:
  : [1]  2  4  6  8 10
  :  [1]  2  2  4  4  6  6  8  8 10 10
  :  [1]  2  4  6  8 10  2  4  6  8 10
  :  [1]  2  2  4  4  6  6  8  8 10 10

~sort(rep(x)) = rep(sort(x))~ holds when ~rep~ uses a consistent
repetition that preserves the element frequencies, and the sorted form
of ~x~ matches the sorted form of ~x~ repeated. If ~rep~ arguments differ
like ~sort(rep(x,2))~ and ~rep(sort(x),3)~, lengths/counts mismatch
breaking equality. but for standard calls ~rep(x,n)~ vs ~rep(sort(x),n)~
they're equal post-sorting.

* DONE Week 9: ~break~ ~next~ ~repeat~ and ~function~ deep dive
#+attr_html: :width 400px :float nil:
#+caption: Monte Carlo Casino
[[../img/monte-carlo-casino.jpg]]

- [X] Any feedback on the Literature Review sprint review?

- [X] *Tests*: Former rule (50% after the deadline) reinstalled (because
  there aren't enough days left in the term for the other rule :-) But
  you can complete the tests now at any time for 50% of the points
  until May 2nd (term ends May 9th).

- [X] *Test 5* is live: 50 questions on loops, projects, utilities. Uses
  lectures and review sessions (available in GitHub) as
  usual. Deadline March 21 (2 weeks).

- [X] Loop control with ~break~, ~next~ and ~repeat~. Get:
  [[https://raw.githubusercontent.com/birkenkrahe/ds2-25/refs/heads/main/org/9_simulation_codealong.org][tinyurl.com/simulation-codealong]] and open it in Emacs as =simul.org=.

** Checkpoint GAI
#+attr_html: :width 400px :float nil:
[[../img/debug.png]]

- I'm enjoying re-developing my lectures and exercises with
  Grok 3. It's generally more code-friendly than ChatGPT.

- At the same time, every single code block in the current lecture was
  wrong. The AI got the simplest things wrong (same for ChatGPT).

- By testing every line of its code, improving and enlarging it, I
  learnt something myself. If only to make sure I know what I code.

- Though for professional applications, it's crap.

** Review: loop control with ~break~ and ~next~

1. You’re counting books on a shelf until you hit a "BROKEN"
   one. Loop over the vector =shelf=, stop at every ="BROKEN"= book and
   return the indices of these books. (Can you do it on one line?)

   #+begin_src R :session *R* :results output :exports both
     shelf <- c("Miller", "Moon", "BROKEN", "Nantucket", "BROKEN")  # Define shelf
     which(shelf=="BROKEN")
   #+end_src

   #+RESULTS:
   : [1] 3 5

   #+begin_quote
   You only need ~break~ if you actually want to break out of a loop.
   #+end_quote

2. You’re adding up scores like ~c(10, "skip", 15, 5)~ but need to
   ignore non-numeric entries. What’s a ~for~ loop with ~next~ in R to
   print only the numbers? (Can you do it on one line?)

   #+begin_src R :session *R* :results output :exports both
     scores <- c(10, "skip", 15, 5)
     for (item in scores) if (!is.na(suppressWarnings(as.numeric(item)))) print(as.numeric(item))
   #+end_src

   #+RESULTS:
   : [1] 10
   : [1] 15
   : [1] 5

   #+begin_quote
   You only need ~next~ if you actually want to skip loop events.
   #+end_quote

3. You’re flipping a coin until you get heads, tracking how many flips
   it takes. How could a ~repeat~ loop with ~break~ look in R to stop at
   the first "H"? (Can you do it in one line?)

   #+BEGIN_SRC R :results output :session *R*
     repeat {if((sample(c("H","T"),1)=="H"->H)) break}
     H
   #+END_SRC

   #+RESULTS:
   : [1] TRUE

4. You’re counting "win" streaks in a vector of "win" and "lose"
   results until two wins in a row. How might a ~for~ loop with ~break~
   and ~next~ reset at "lose" in R? Write the pseudocode! Then the code!

   Pseudocode:
   #+begin_example
   ## define results vector
   ## initialize streak
   ## for each result in results
      ## if result is "lose"
         ## set streak to zero
         ## next result
      ## increment streak
      ## if streak is two
         ## break loop
   ## print streak
   #+end_example

   Code:
   #+begin_src R :session *R* :results output :exports both
     results <- sample(c("win","lose"),5,TRUE) ## define results vector
     streak <- 0 ## initialize streak
     for (result in results) { ## for each result in results
       if (result == "lose") { ## if result is "lose"
         streak <- 0 ## set streak to zero
         next } ## next result
       streak <- streak + 1 ## increment streak
       if (streak == 2) ## if streak is two
         break} ## break loop
     ## print streak position
     paste("Streak:",streak)
     results
   #+end_src

   #+RESULTS:
   : [1] "Streak: 2"
   : [1] "win"  "lose" "win"  "win"  "lose"

5. What if you want to identify the position of the 2nd win (if any)?

   #+begin_src R :session *R* :results output :exports both
     results <- sample(c("win","lose"),5,TRUE) ## define results vector
     streak <- 0 ## initialize streak
     for (i in 1:length(results)) { ## for each result in results
       if (results[i] == "lose") { ## if result is "lose"
         streak <- 0 ## set streak to zero
         next } ## next result
       streak <- streak + 1 ## increment streak
       if (streak == 2) ## if streak is two
         break ## break loop
     }
     ## print streak position
     if (i < length(results)) {
       paste("Position of 2nd win:",i)
     } else {
       paste("No 2nd win.")
     }
     results
   #+end_src

   #+RESULTS:
   : [1] "Position of 2nd win: 2"
   : [1] "win"  "win"  "lose" "lose" "lose"

TO FIX: ="win"  "win"  "lose" "lose" "lose"= generates a bug!

* DONE Week 10: Real World Problems
#+attr_html: :width 400px :float nil:
#+caption: The Dukes of Burgundy and their ladies (15th century AD)
[[../img/tolerant.jpg]]

- [X] Test 5 is due this Friday March 21st
- [X] Titanic Survival Analysis with ~tapply~ due today March 18th
- [X] DataCamp course ("Writing functions") due April 1st
- [X] New home programming assignment (MC simulation)
- [X] Advisees: I will share degree plans & you upload to GDrive

** Review Questions for Monte Carlo Simulation

1. What is the main purpose of using the Monte Carlo method to
   estimate π?
   #+BEGIN_QUOTE
   To approximate π by simulating random points and using their
   distribution to estimate the ratio of areas.
   #+END_QUOTE

2. How does the Monte Carlo method use the relationship between two
   geometric shapes, such as a quarter-circle inscribed in a unit
   square, to estimate a mathematical constant?
   #+BEGIN_QUOTE
   The method compares the proportion of random points falling within
   the quarter-circle to the total area of the unit square, which
   reflects the constant’s value based on the area formula
   #+END_QUOTE

3. Why is it important for the random points in the Monte Carlo method
   to be uniformly distributed?
   #+BEGIN_QUOTE
   Uniform distribution ensures that all areas within the sampling
   region have an equal chance of being sampled, providing a fair
   estimate of the target value.
   #+END_QUOTE

4. What geometric relationship allows the Monte Carlo method to
   estimate π from the ratio of points inside and outside a specific
   region?
   #+BEGIN_QUOTE
   The ratio of the area of a curved region to a surrounding area is
   related to π because the curved region’s area is a fraction of π
   multiplied by a known dimension, specifically the radius (e.g., r
   = 1) of the quarter-circle around (0,0).
   #+END_QUOTE

5. How does increasing the number of random points in a Monte Carlo
   simulation affect the accuracy of the π estimate?
   #+BEGIN_QUOTE
   Increasing the number of points generally improves accuracy by
   reducing the impact of random variation, as more samples better
   reflect the true proportion.
   #+END_QUOTE

6. What is the key idea behind stopping a Monte Carlo simulation based
   on precision rather than a fixed number of points?
   #+BEGIN_QUOTE
   The simulation stops when the estimate stabilizes, indicating that
   additional points are unlikely to significantly change the result.
   #+END_QUOTE

7. How does the Monte Carlo method handle uncertainty in estimating
   outcomes like π?
   #+BEGIN_QUOTE
   It uses repeated random sampling to simulate a range of possible
   outcomes and derive an average or approximate value.
   #+END_QUOTE

8. In the context of processing log data with a ~while~ loop, what
   role does an error value (like -999) play in the simulation?
   #+BEGIN_QUOTE
   The error value acts as a signal to stop or adjust the processing
   when an invalid or problematic data point is encountered. Example:
   Halting the calculation of server uptime when a system crash is
   logged.
   #+END_QUOTE

9. What is the conceptual goal of simulating a dice game with a ~for~ or
   ~repeat~ loop until the sum exceeds a threshold?
   #+BEGIN_QUOTE
   To model a sequence of random events and determine how many steps
   are needed to reach a specific condition. Example: Deciding when to
   end a game based on a player’s total score.
   #+END_QUOTE

10. How might adding a condition like requiring a specific roll (e.g.,
    a 6) to stop a simulation change the approach to analyzing the
    results?
    #+BEGIN_QUOTE
    It introduces an additional constraint, requiring the simulation
    to consider both the cumulative outcome and the nature of the
    final event. Example: Analyzing a dice game where a win is
    declared only if a 6 is rolled after exceeding a score threshold,
    affecting the strategy for predicting victory.
    #+END_QUOTE

** More real world problems solved with functions

Lecture and practice: [[https://tinyurl.com/real-world-practice][tinyurl.com/real-world-practice]]

Topics:
- [X] Lazy evaluation of function arguments
- [X] Checking for missing arguments
- [X] Using ellipses to customize plots
- [ ] Bonus: Matrix multiplication in Python vs R
- [ ] Bonus: Using ~tapply~ to split data into weekly groups

* DONE Week 11: Writing functions like a pro / "Tidyverse" rant
#+attr_html: :width 400px :float nil:
#+caption: Vincent van Gogh, The Painter on the Road to Tarascon (1888)
[[../img/1-the-painter-on-his-way-to-work-vincent-van-gogh.jpg]]

- [X] DataCamp course "Writing functions in R" extended to Friday
- [X] No class meeting on Tuesday, April 22 (Honors Convocation)
- [X] 2nd sprint review
- [X] DataCamp review: functions (only chapter 1)
- [ ] Code along: Writing functions like a Pro
- [ ] "Tidyverse" vs. Base R

** 2nd Sprint Review - the key lessons as cartoons

*** Issues

1. Uploaded the litmap but not any of the sources: the AI cannot
   guess your content. You have to upload the source itself (10%).
2. No signs of having worked with the source material, for example
   by asking questions suggested by the AI (10%).
3. No signs of having worked with the podcast (10%).
4. Late submission (50%).

*** Highlights

- Kelli's proposal (and podcast): very focused, well-sourced.
- Donna's proposal (and podcast): very focused, well-sourced.
- Both podcasts were interesting to listen to. AI had no problem
  identifying the research question (good test).

*** Research skills are really important in tech
#+attr_html: :width 400px :float nil:
[[../img/skills.png]]

To clarify: "Research" includes all activities to settle questions
that you cannot answer on your own. "Papers" here only means
"scientific publications", not essays assigned in other classes.

*** To succeed you need to muster (and show) enthusiasm
#+attr_html: :width 400px :float nil:
[[../img/enthusiasm.png]]

*** When you work with clients, make it easy for them
#+attr_html: :width 400px :float nil:
[[../img/clients.png]]

Always communicate a little more than you think you should!

*** To work "smart", you first have to work hard
#+attr_html: :width 400px :float nil:
[[../img/smart.png]]

*** Competent use of AI for research depends on your input
#+attr_html: :width 400px :float nil:
[[../img/ai.png]]

*** You can still change your project if you like
#+attr_html: :width 400px :float nil:
[[../img/change.png]]

Be mindful that if you know only little (or nothing), your time
estimate is off by a factor 2 (or 3).


** DataCamp review - How to Write a Function

1) Which ways are there to pass arguments to a function?
   #+begin_src R :session *R* :results output :exports both
     mean(1:5) # positional
     mean(x=1:5) # exact/named
     mean(c(1:5,NA),na.rm=TRUE) # mixed/hybrid

     ## common arguments: positional
     ## rare arguments: named
   #+end_src

2) What does the ~trim~ parameter of the ~mean~ function do?
   #+begin_quote
   It says which fraction of observations (0 to 0.5) to be dropped
   from either end of the *sorted* vector argument before averaging.
   #+end_quote

3) Demonstrate the ~trim~ parameter of the ~mean~ function with a suitable
   vector.
   #+begin_src R :file foo.png :session *R* :results output graphics file :exports both
     foo <- c(100,-1,0,1,100)
     hist(foo,breaks=1) # non-symmetric distribution
   #+end_src

   #+begin_src R :session *R* :results output :exports both
     mean(foo)

     mean(foo,trim=0.25)  # drop 1 value on either side AFTER SORTING
     mean(sort(foo)[c(-1,-5)])

     mean(foo,trim=0.5)  # drop 1 value on either side AFTER SORTING
     sort(foo)[c(-1,-2,-4,-5)]
     mean(sort(foo)[c(-1,-2,-4,-5)])
   #+end_src

   #+RESULTS:
   : [1] 40
   : [1] 33.66667
   : [1] 33.66667
   : [1] 1
   : [1] 1
   : [1] 1

4) Does ~median~ behave like ~mean~?
   #+begin_src R :session *R* :results output :exports both
     args(median)
     args(mean)
   #+end_src

   #+RESULTS:
   : function (x, na.rm = FALSE, ...)
   : NULL
   : function (x, ...)
   : NULL

5) Ellipsis arguments for ~mean~ - apart from ~na.rm~ - what're they for?
   #+begin_quote
   You can roll your own data structures and define methods for it.
   #+end_quote

   #+begin_src R :session *R* :results output :exports both
     mean.myclass <- function(x,...,verbose=FALSE) { # default: NOT verbose
       if(verbose) {
         cat("Calculating mean for object of class 'myclass'\n")
       }
       mean(as.numeric(x)) # default: arithmetic numeric mean
     }

     mean(1:10)
     mean(1:10,verbose=TRUE) # defaults to mean.default()

     x <- structure(1:10, class="myclass")
     mean(x,verbose=TRUE) # calls mean.myclass
     class(mean)
     class(x)
   #+end_src

   #+RESULTS:
   : [1] 5.5
   : [1] 5.5
   : Calculating mean for object of class 'myclass'
   : [1] 5.5
   : [1] "function"
   : [1] "myclass"

6) Which of the ~methods~ of ~mean~ takes the average of date values?
   #+begin_src R :session *R* :results output :exports both
     cat(paste(methods("mean"), collapse="\n")) # show content on lines
     methods(mean) # show content as vector with junk
   #+end_src

   #+RESULTS:
   : mean.Date
   : mean.default
   : mean.difftime
   : mean.myclass
   : mean.POSIXct
   : [1] mean.Date     mean.default  mean.difftime mean.myclass  mean.POSIXct  mean.POSIXlt
   : see '?methods' for accessing help and source code

7) Average a ~seq~ of 5 ~Sys.Date~ values separated by ~"day"~.
   #+begin_src R :session *R* :results output :exports both
     ## Generate a few date values from Sys.Date onwards
     seq.Date(from=Sys.Date(), by="day", length.out=5) -> dates
     dates
     class(dates) # this is "Date" class because we used seq.Date
     mean(dates)
   #+end_src

   #+RESULTS:
   : [1] "2025-04-01" "2025-04-02" "2025-04-03" "2025-04-04" "2025-04-05"
   : [1] "Date"
   : [1] "2025-04-03"

9) Why should you roll your own functions?
   #+begin_quote
   - New functionality: Functions should do stuff.
   - Reuse code: Call function with different arguments.
   - Ease maintenance: Debug in one place only.
   #+end_quote

10) What are the steps to convert a script to a function?
    #+begin_quote
    1. Make a template
    2. Paste in the script
    3. Choose the arguments
    4. Replace specific values with argument names
    5. Make specific variable names more general
    6. Remove a final assignment

    See also: Home programming assignment. Note: The assignment asks
    for *one code block per step* to force you to go through the sequence
    at least once consciously.
    #+end_quote

11) Tidyverse crash course: Can you explain this code?
    #+begin_src R :session *R* :results output :exports both
      library(dplyr)
      library(readr)
      library(lubridate)
      import_test_scores <- function(filename) {
        test_scores_raw <- read_csv(filename)
        test_scores_raw %>%
          select(person_id, first_name, last_name, test_date, score) %>%
          mutate(test_date = mdy(test_date)) %>%
          filter(!is.na(score))
      }
      import_test_scores("../data/test_scores.csv")
    #+end_src

    With comments:
    #+begin_src R :session *R* :results output :exports both
      library(readr)  # load for read_csv
      library(dplyr)  # load for select, filter, mutate
      library(lubridate) # load for mdy

      ## function definition
      import_test_scores <- function(filename) { # accept filename
        ## read CSV data from `filename`
        test <- read_csv(filename)
        ## process raw test scores from a 'tibble'
        test %>%
          ## select columns
          select(person_id, first_name, last_name, test_date, score) %>%
          ## transform test date column
          mutate(test_date = mdy(test_date)) %>%
          ## remove records with missing test scores
          filter(!is.na(score))
      }

      import_test_scores("../data/test_scores.csv")
    #+end_src

    - Explanation:
      #+begin_quote
      - The CSV file is imported as a "tibble" (call ~help~ on
        that). That's a data structure in the "Tidyverse".
      - ~select~ picks existing column names.
      - ~mutate~ transforms =test_date= into ~Date~ type
      - ~mdy~ transforms a string like =03-15-2024= to ~Date~ format.
      - Uses ~dplyr~ pipeline (~%>%~).
      - Requires knowledge of multiple functions across different
        libraries.
      #+end_quote

12) Could you turn the Tidyverse code from before into base R code?
    #+begin_src R :session *R* :results output :exports both
      import_test_scores2<-function(filename) {
        test2<-read.csv(filename)
        test2<-test2[c("person_id","first_name","last_name", "test_date","score")]
        test2["test_date"]<-as.Date(test2["test_date"][,1], format="%m-%d-%Y")
        test2[which(!is.na(test2[,"score"])),]
      }
      import_test_scores2("../data/test_scores.csv")
    #+end_src

    - With comments:
      #+begin_src R :session *R* :results output :exports both
        ## function definition
        import_test_scores2 <- function(filename) { # accept filename
          ## read CSV data from `filename`
          test2 <- read.csv(filename)
          ## process raw test scores
          ## select columns
          test2[c("person_id", "first_name", "last_name", "test_date",
                  "score")] -> test2
          ## transform test date column
          test2["test_date"] <- as.Date(test2["test_date"][,1], # extract vector
                                        format="%m-%d-%Y")     # mm-dd-YYYY
          ## remove records with missing test scores
          which(!is.na(test2[,"score"])) -> idx # flag vector (non-NA)
          test2[idx,]
        }
        import_test_scores2("../data/test_scores.csv")
      #+end_src

    - Explanation:
      #+begin_quote
      - No libraries need to be imported - everything already built-in.
      - CSV data imported as standard ~data.frame~.
      - Select columns using column vector names.
      - Transform =test_date= to ~Date~ type using ~as.Date~ (pick format).
      - Remove records with missing =score= values using ~which~.
      - Requires complete control of vector index arithmetic.
      #+end_quote


** "Tidyverse" vs Base R Comparison (by Grok)

Based on the example of importing and processing test scores from a
CSV file (to be found in DataCamp and in my lecture).

*** Tidyverse
**** Pros
- *Readability and Structure*: Uses the pipe operator (~%>%~) to
  organize operations (read, select, mutate, filter) into a sequential
  flow, which may clarify intent for some users.
  - Example:
    #+begin_src R
      test_scores_raw %>% select(...) %>% mutate(...) %>% filter(...)
    #+end_src
    follows a step-by-step pattern.
- *Tibble Data Structure*: Employs tibbles (via ~read_csv~), which are
  data frames with stricter subsetting rules (e.g., no partial column
  name matching) and detailed output formatting, potentially aiding
  data inspection.
- *Specialized Functions*: Includes libraries like ~lubridate~ with
  functions (e.g., ~mdy()~) that handle date parsing with less manual
  input than base R’s ~as.Date()~ with format strings.
- *Consistent Syntax*: Functions share a naming convention (e.g.,
  ~select~, ~mutate~, ~filter~), which may streamline learning
  additional tasks within the ecosystem.
- *Community Support*: Has widespread use, with extensive documentation
  and integration with tools like ~ggplot2~ for visualization, useful
  in shared or teaching contexts.

**** Cons
- *Dependencies Required*: Relies on multiple external packages
  (~dplyr~, ~readr~, ~lubridate~), increasing setup steps and
  potential version conflicts.
  - Example: Requires three ~library()~ calls:
    #+begin_src R
      library(dplyr)
      library(readr)
      library(lubridate)
    #+end_src
- *Learning Requirements*: Assumes knowledge of specific functions and
  the pipe operator, which may challenge users unfamiliar with its
  conventions.
- *Performance Overhead*: For small datasets, differences are minimal,
  but may run slower than base R for larger datasets due to additional
  processing (e.g., tibble creation, pipe operations).
- *Reduced Transparency*: High-level functions (e.g., ~select~,
  ~mutate~) abstract vector operations, potentially limiting
  visibility into data manipulation details.

*** Base R
**** Pros
- *No External Packages*: Uses only built-in functions (~read.csv~,
  ~as.Date~, ~which~), requiring no additional installations or
  loading steps.
  - Example: No ~library()~ calls needed.
- *Direct Manipulation*: Allows explicit control over vector and index
  operations (e.g., ~test2["test_date"][,1]~, ~which()~), precise for
  tailored data handling.
- *Performance Potential*: Can execute operations faster, especially on
  large datasets, by avoiding Tidyverse’s additional features.
- *Built-In Availability*: As part of R’s core, functions are
  universally accessible and less prone to breaking due to package
  updates.
- *Compact for Basic Tasks*: For straightforward operations like this
  example, requires fewer lines and no external setup.

**** Cons

- *Less Sequential Flow*: Uses subsetting (~test2[c(...)]~) and indexing
  (~test2[idx,]~) in a way that may feel less linear, requiring more
  effort to trace.
  - Example:
    #+begin_src R
      test2[which(!is.na(test2[,"score"])),]
    #+end_src
    combines multiple steps in one line.

- *Manual Specification*: Tasks like date conversion require explicit
  format definitions (e.g., ~as.Date(test2["test_date"][,1],
  format="%m-%d-%Y")~), adding more detail to specify.

- *Indexing Complexity*: Reliance on manual indexing (e.g., ~[,1]~) and
  subsetting increases error risk if data structures change or type
  assumptions fail.

- *Basic Output*: ~data.frame~ lacks formatted printing or strict
  subsetting, which may complicate interactive data review compared to
  "tibbles".

*** Summary Based on the Example

- *Tidyverse*: Stands out for its step-by-step structure and simplified
  date handling via ~lubridate~. Requires external packages and
  familiarity with its syntax.

- *Base R*: Notable for its lack of dependencies and direct
  approach. Involves more manual steps and a less flowing syntax.

*** Recommendation

- Use *Tidyverse* if working where additional packages are available,
  and a pipeline structure or ecosystem tools (e.g., ~ggplot2~) are
  priorities (not for production code).

- Use *Base R* if avoiding dependencies is key, or if precise control
  without external tools is preferred (for production code).

Both methods produce the same output in this example, so the decision
depends on package availability, coding style preferences, and
performance needs.

*** Improved Base R Code

- More robust against variations in input data (e.g., missing columns,
  different date formats).

- Clearer structure with consistent data frame access (~$~ over ~[ , ]~
  where possible).

- Maintains base R’s no-dependency advantage while improving
  readability and safety.

- Produces identical output to the original for the given example, but
  scales better to diverse datasets.

#+begin_src R :session *R* :results output :exports both
  import_test_scores_base <- function(filename) {
                                          # Read CSV with explicit stringsAsFactors and check.names options
    test_data <-
      read.csv(filename, stringsAsFactors = FALSE, check.names = FALSE)

                                          # Define columns to keep
    cols_to_keep <-
      c("person_id", "first_name", "last_name", "test_date", "score")

                                          # Subset columns, ensuring they exist in the data
    test_data <- test_data[, intersect(cols_to_keep, names(test_data))]

                                          # Convert test_date to Date, handling potential errors
    test_data$test_date <-
      as.Date(test_data$test_date, format = "%m-%d-%Y",
              tryFormats = c("%m-%d-%Y", "%Y-%m-%d"))

                                          # Filter non-NA scores, preserving data frame structure
    test_data[!is.na(test_data$score), , drop = FALSE]
  }

                                          # Example call
  import_test_scores_base("../data/test_scores.csv")
#+end_src

#+RESULTS:
:   person_id first_name last_name  test_date score
: 1         1       John     Smith 2024-03-15    88
: 2         2      Emily     Jones 2024-04-01    92
: 4         4      Sarah    Wilson 2024-03-28    75
: 5         5      David   Johnson 2024-03-30    80


** TODO Writing your own functions

- [X] Writing functions for new functionality
- [X] Long and short version of functions
- [X] Global and local environment
- [X] Comparing function performance
- [ ] Converting a script to a function
- [ ] Converting "Tidyverse" function to base R function

I have to check the remainder of the DataCamp lesson for more
extensions (returning multiple values/case study).

Download the codealong file: [[https://tinyurl.com/functions-codealong][tinyurl.com/functions-codealong]]

#+begin_example
  wget -O functions.org tinyurl.com/functions-codealong
#+end_example

* DONE Week 12: Data science on the command-line
#+attr_html: :width 200px :float nil:
#+caption: Leonardo Da Vinci doing data science on the command-line
[[../img/leonardo.png]]

- [X] *New DataCamp lesson*: Downloading data on the command-line
- [X] *New test on functions* (deadline this Friday)
- [X] *New home assignment:* Script to function (deadline this Friday)
- [X] *Review* of last week (Writing functions) & continue lesson
- [X] *DataCamp lessons*: Complete "Data Processing in Shell" by May 9th.

- [X] *NO CLASS NEXT TUESDAY 22 APRIL*: Go to *11 AM* Honors Convocation.

** DataCamp lesson: Data Processing in Shell

*Note: The first lesson (30 min) is due on Friday of this week!*

- Downloading data on the command-line (~wget~, ~curl~ - Unix).
- Data cleaning and munging (~csvkit~ - Python).
- Database Operations on the Command Line (~sql2csv~, ~RSQLite~).
- Data Pipeline on the Command Line (~Python~ / Unix).

** Review: Writing functions like a pro / "Tidyverse"

[[https://github.com/birkenkrahe/ds2-25/blob/main/pdf/popquiz_functions.pdf][Popquiz! (PDF)]]

Time = 20 minutes - then 10 min review of the answers.

1. Why would you create a function like ~calc_midrange~?
   #+begin_quote
   To extend functionality: The midrange (the average of the maximum
   and minimum values of a numeric vector) is not a built-in function.
   #+end_quote

2. Which argument must be included in built-in functions ~max()~ and
   ~min()~ to correctly handle missing values?
   #+begin_quote
   The argument ~na.rm=TRUE~ must be included to ignore ~NA~ values.
   #+end_quote

3. What is a key advantage of the one-liner version of ~calc_midrange~
   over the longer version, and can you write the function down now?
   #+begin_src R :session *R* :results output :exports both
     calc_midrange2 <- function(x){(min(x,na.rm=T)+max(x,na.rm=T))/2}
     calc_midrange2(c(1:10,NA))
   #+end_src

   #+RESULTS:
   : [1] 5.5

   #+begin_quote
   It is shorter and potentially faster due to reduced object creation
   and simpler execution.
   #+end_quote

4. Why can't you access the variables ~max_val~ or ~min_val~ outside of
   the ~calc_midrange~ function?
   #+begin_quote
   Because they are local variables defined inside the function's
   scope. You can make them global with the ~<<-~ operator.
   #+end_quote

5. What package is used to benchmark R functions, and what function
   from that package is used to run the benchmark?
   #+begin_quote
   The ~microbenchmark~ package is used, and the function is
   ~microbenchmark()~.
   #+end_quote

6. What is one key benefit of using the Tidyverse pipe operator ~%>%~ in
   data workflows? What is one disadvantage of a pipe?
   #+begin_quote
   It organizes operations into a sequential, readable flow (e.g.,
   ~select %>% mutate %>% filter~) that clarifies intent.

   A disadvantage is that it makes debugging more difficult because no
   objects are saved intermittently.
   #+end_quote

7. What function was created to check whether a package like
   ~microbenchmark~ is loaded in the current R session? Can you write
   the function down?
   #+begin_src R :session *R* :results output :exports both
     loaded <- function(x){search()[grep(x,search())]}
     library(microbenchmark)
     loaded("microbenchmark")
   #+end_src

   #+RESULTS:
   : [1] "package:microbenchmark"

   #+begin_quote
   A user-defined function named ~loaded~ that uses ~grep()~ on the
   output of ~search()~.
   #+end_quote

8. Why might someone prefer Base R over "Tidyverse" for importing and
   cleaning a CSV file in a production environment?
   #+begin_quote
   Base R avoids external dependencies, offers direct control, is less
   likely to break due to package updates, and is less function-heavy.
   #+end_quote

9. What R function can save another function to a file for later
   reuse? Can you write down an example using the function =loaded=, and
   then check from within R if the file was created?
   #+begin_src R :session *R* :results output :exports both
     dump("loaded",file="loaded.R")
     system("ls -l loaded.R")
   #+end_src

   #+RESULTS:
   : -rw-rw-r-- 1 marcus marcus 50 Apr  8 11:28 loaded.R

10. What is a common disadvantage of using Tidyverse functions like
    ~select~ and ~mutate~ compared to Base R?
    #+begin_quote
    They abstract away vector operations like ~$~ and ~[]~, which can
    reduce transparency and limit understanding of underlying
    processes.
    #+end_quote

** Writing your own functions

- [X] Writing functions for new functionality
- [X] Long and short version of functions
- [X] Global and local environment
- [X] Comparing function performance
- [X] Converting a script to a function
- [X] Converting "Tidyverse" function to base R function

I have to check the remainder of the DataCamp lesson for more
extensions (returning multiple values/case study).

Download the codealong file: [[https://tinyurl.com/functions-codealong][tinyurl.com/functions-codealong]]

#+begin_example
  wget -O functions.org tinyurl.com/functions-codealong
#+end_example

** My apologies - the price of research
#+attr_html: :width 200px :float nil:
[[../img/colloq.png]]

Every 2 years or so I give a faculty colloquium that absorbs
approx. 50% of my energy in the 2 weeks before the event.

You can help me by sending me (written) accounts of how you are using
AI for research purposes (to any extent: search, structure, writing).

You'll pay a price because I'll be uncharacteristically scattered,
and/or less prepared (all of the following lectures are brand-new).

** Installing and testing ~csvkit~

~csvkit~ is a Python library of command-line data science functions.

- Can you install ~csvkit~ locally? Try:
  #+begin_example
  which pip # if this works then try:
  pip install --user csvkit &  # prefix with `sudo` if its your machine
  ps
  #+end_example

- This will take quite a while

- An alternative: Open Google colab (~colab.research.google.com~), run:
  #+begin_example
  !pip install --quiet csvkit
  #+end_example

- Check with
  #+begin_src bash :results output :exports both
    csvcut --help
  #+end_src

- To do: add ~~/.local/bin~ to the ~PATH~ of your computer

** Review: OSEMN

[[https://github.com/birkenkrahe/ds2-25/blob/main/pdf/popquiz_OSEMN.pdf][Popquiz! (PDF)]]

1. What does the acronym OSEMN stand for in the data science pipeline?
   #+begin_quote
   Obtain, Scrub, Explore, Model, Interpret
   #+end_quote

2. Which stage of the OSEMN framework typically takes up 80% of the
   work in data science?
   #+begin_quote
   Scrub
   #+end_quote

3. What is one reason the data science pipeline is described as a
   "pipe-mess"?
   #+begin_quote
   Because the steps aren't neatly separated in practice—they happen
   all at once and repeatedly.
   #+end_quote

4. What are some common tasks in the “Scrub” step of the data science
   pipeline?
   #+begin_quote
   Filtering lines, selecting columns, replacing values, removing
   stopwords, *handling missing data*, converting formats
   #+end_quote

5. What are some common activities in the “Explore” stage of the OSEMN pipeline?
   #+begin_quote
   Viewing data structure, *summarizing statistics*, creating
   visualizations, transforming data
   #+end_quote

6. Give an example of a modeling technique from the OSEMN pipeline.
   #+begin_quote
   k-means clustering, k-nearest neighbors, *linear regression*, neural
   networks, principal components analysis
   #+end_quote

7. Why is the command-line considered “agile” for data science?
   #+begin_quote
   It provides a *REPL* (Read-Eval-Print-Loop) for quick interaction and
   is close to the filesystem (to the OS/kernel) for fast access
   #+end_quote

8. How does the command-line support *scalability* in data science
   workflows?
   #+begin_quote
   Through scripting, *platform independence*, automation (cron), *remote
   execution*, and parallel processing
   #+end_quote

9. What makes the command-line “extensible”?
   #+begin_quote
   It's under active development, *language-agnostic*, *open source*, and
   allows custom tool creation
   #+end_quote

10. List three reasons why the command-line is considered ubiquitous
    in data science.
    #+begin_quote
    It comes with every Unix-like OS, runs on all supercomputers and
    grid computing networks, and is used on servers and embedded
    systems
    #+end_quote

11. Bonus question: which fun Unix programs were introduced? Name at
    least one!
    #+begin_example
    fortune
    yes
    cowsay
    sl
    #+end_example

** Using GAI when doing research (help me help you)
#+attr_html: :width 600px :float nil:
[[../img/muse_or_tool.png]]

- Please take 30 minutes to fill in my short *anonymous* survey:
  [[https://tinyurl.com/ai-muse-or-tool-students][tinyurl.com/ai-muse-or-tool-students]]

  1. *How are you using AI in your coursework?*

  2. *Do you consider AI more of a muse or more of a tool?*

  3. *What would you like to hear in my presentation?*

- Please write as much as you can. We'll look at the results later.

** Project review

- Write your abstract now without using any sources other that what's
  in your head right now:

  1. Current title of your project

  2. A description of results you did obtain so far

  3. A description of the results you did not obtain yet

  4. A list of references that you remember by heart

  5. Your greatest (non-trivial, i.e. not “time”) issue right now when
     you think about the presentation.

- Put your answer in this Google Docs file (find your project name):
  [[https://tinyurl.com/dsc205-project-abstract][tinyurl.com/dsc205-project-abstract]]

** For my own project (Faculty Colloquium presentation/paper/research)

1. Title: "Artificial Intelligence - Muse or Tool"

2. Results I obtained so far:

   - Multiple conversations with two different GAI models on this and
     other topics, which gave me the idea for the current topic.

   - Multiple conversations with humans on aspects of the talk,
     including: What exactly is research (then and today)? What is the
     role of a muse in research, what is the role of digital tools, and
     of non-digital tools?

   - Many, many questions, few answers.

   - A LaTeX slide deck that I'm not going to use.

   - Many posters two of whom I'm going to use to market the talk.

   - Abstract (250 words), several almost completely different
     summaries.

   - A list of lame AI jokes to open and close the talk with.

   - A very long list of sources (papers, blogs, videos, etc.), probably
     100-200 in total (I haven't listed them yet - should have!).

   - A framework on working on a difficult research project with AI.

3. Results I haven't got yet (but need):

   - Slide deck.

   - Entry and exit survey questions.

   - Joke at the beginning and at the end.

4. References

   - Terence Tao video on using AI for math research.

   - Video from Oxford Mathematics on math as a muse for philosophy.

   - Stephen Wolfram's little book on ChatGPT (2023).

5. Greatest issue for the upcoming presentation:

   - Will I be able to do last-minute academic research?

   - Which examples am I going to use?

** Lecture/Practice: Data Science on the Command Line

See also: DataCamp course "Introduction to Shell" (no prerequisites).

- [X] Data science "pipe-mess" (OSEMN)
- [X] What is the command line?
- [X] Why is the command line awesome for data science?
- [ ] Essential Unix concepts
- [ ] Types of command-line tools
- [ ] Combining command-line tools
- [ ] Redirecting command-line tools
- [ ] Working with files and directories
- [ ] Managing output

* DONE Week 13: More data science on the command-line
#+attr_html: :width 200px :float nil:
[[../img/talk.png]]

** Lecture/Practice: [More] Data Science on the Command Line

See also: DataCamp course "Introduction to Shell" (no prerequisites).

- [X] Data science "pipe-mess" (OSEMN)
- [X] What is the command line?
- [X] Why is the command line awesome for data science?
- [X] Essential Unix concepts
- [ ] Types of command-line tools
- [ ] Combining command-line tools
- [ ] Redirecting command-line tools
- [ ] Working with files and directories

* Week 14: It's a wrap! Optimizing code with =C++= and ~RCpp~
#+attr_html: :width 200px :float nil:
[[../img/wrap.png]]

*Decision time*:
- [X] We need 2 presentations on Thursday, May 1.
- [X] You'll be trailblazing for others! Bonus mind!
- [X] The rest of you will present next week.

*Topics*:
- [X] *Course Evaluations*: Take 10 minutes to evaluate this course!
- [X] *Popquiz!* Pre-view for test 7 (due Tue May 6th).
- [X] *Finish:* We'll finish command line data science!
- [X] *Optimize:* We'll take a peek at the Rcpp package.

*Grading:*
- [X] Test 7 (command-line, May 6th) & test 8 (csvkit, May 9th)
- [X] Remember the DataCamp course deadline (May 9th)
- [X] Submit missed assignments (DataCamp or homework) for 50%

** DONE Review (ungraded popquiz) "DS @ CLI"

1. Where does the *absolute path*, where does the *relative path* begin?
   #+begin_quote
   - An absolute path starts from the root (~/~), independent of the
     current working directory (or =C:= on Windows).
   - A relative path starts from whereever you are right now.
   #+end_quote

2. What command shows your *current working directory*? (Where you are.)
   #+begin_quote
   ~pwd~
   #+end_quote

3. In command-line tools, what are *options*? Example for ~ls~?
   #+begin_quote
   Options (or 'flags') are arguments that modify the behavior of a
   command-line tool. For ~ls~, examples are ~-lt~ (long, time-ordered).
   #+end_quote
   #+begin_src bash :results output
     ls -lt ..
   #+end_src
   
4. What are the five types of command-line tools?
   #+begin_quote
   Binary executables, shell built-ins, interpreted scripts, shell
   functions, and aliases.
   #+end_quote

5. How can you check whether a command like ~cd~ or ~pwd~ is a shell built-in?
   #+begin_quote
   Use ~type commandname~
   #+end_quote
   #+begin_src bash :results output :exports both
     type cd
     type -a curl
   #+end_src

   #+RESULTS:
   : cd is a shell builtin
   : curl is /usr/bin/curl
   : curl is /bin/curl

6. What does the *shebang* line (e.g., ~#!/usr/bin/bash~) specify?
   #+begin_quote
   It tells the system which interpreter to use to execute the script.
   #+end_quote

7. What does ~curl~ do in the context of command-line tools?
   #+begin_quote
   It retrieves data from URLs over supported protocols (like HTTP,
   FTP) but it does not store it in a file unless *redirected* to do so.
   #+end_quote

8. Why is ~>~ called the data "re-direction" symbol? Why not just
   data "direction"?
   #+begin_quote
   Because data by default are directed to ~stdout~ (file descriptor 1),
   and ~>~ re-directs the data to a file.
   #+end_quote

9. What is the purpose of the ~tee~ command in a pipeline?
   #+begin_quote
   It writes output to both standard output and a file simultaneously.
   #+end_quote

10. What is the difference between using ~>~ and ~>>~ when redirecting output?
    #+begin_quote
    ~>~ overwrites a file; ~>>~ appends to a file.
    #+end_quote

11. What command would you use to *list all CSV files* in a relative
    path like ~../data/~?
    #+begin_quote
    ~ls ../data/*.csv~
    #+end_quote

12. What Unix command can you use to *remove carriage return characters*
    (~\r~) from output?
    #+begin_quote
    ~tr -d '\r'~
    #+end_quote

** DONE Final presentations May 1, 6, 8
#+attr_html: :width 400px :float nil:
[[../img/sacrifice.png]]

- Go through the checklist in Canvas/GitHub!
- Rehearse with an audience!
- Test the technology before the presentation!
- Contact me if you have any questions!
- Don't forget to build your GitHub portfolio!
  #+begin_src R :file plot.png :session *R* :results graphics output file :exports both
    contrib <- ts(data=c(76,2141,3704,2454,2998,1075),
                  start=2020)
    plot(contrib,
         main=paste("GitHub contributions 2020-2025 = ", sum(contrib)),
         xlab="year",ylab="Number of contributions",
         type="b")
    grid(col="gray")
  #+end_src

  #+RESULTS:
  [[file:plot.png]]


** DONE Finish "Data science on the command-line"

- Go to Google Cloud Shell: =ide.cloud.google.com=.

- Open the terminal and code along with me.

** DONE Review "Data science on the command-line"

1. Where does the *absolute path*, where does the *relative path* begin?
   #+begin_quote
   - An absolute path starts from the root (~/~), independent of the
     current working directory.
   - A relative path starts from whereever you are right now.
   #+end_quote

2. What command shows your *current working directory*? (Where you are.)
   #+begin_quote
   ~pwd~
   #+end_quote

3. In command-line tools, what are *options*? Example for ~ls~?
   #+begin_quote
   Options (or 'flags') are arguments that modify the behavior of a
   command-line tool. For ~ls~, examples are ~-lt~ (long, time-ordered).
   #+end_quote

4. What are the five types of command-line tools?
   #+begin_quote
   Binary executables, shell built-ins, interpreted scripts, shell
   functions, and aliases.
   #+end_quote

5. How can you check whether a command like ~cd~ or ~pwd~ is a shell built-in?
   #+begin_quote
   Use ~type commandname~
   #+end_quote
   #+begin_src bash :results output :exports both
     type cd
   #+end_src

6. What does the *shebang* line (e.g., ~#!/usr/bin/bash~) specify?
   #+begin_quote
   It tells the system which interpreter to use to execute the script.
   #+end_quote

7. What does ~curl~ do in the context of command-line tools?
   #+begin_quote
   It retrieves data from URLs over supported protocols (like HTTP,
   FTP) but it does not store it in a file unless redirected to do so.
   #+end_quote

8. Why is ~>~ called the data "re-direction" symbol? Why not just
   data "direction"?
   #+begin_quote
   Because data by default are directed to ~stdout~ (file descriptor 1),
   and ~>~ re-directs the data to a file.
   #+end_quote

9. What is the purpose of the ~tee~ command in a pipeline?
   #+begin_quote
   It writes output to both standard output and a file simultaneously.
   #+end_quote

10. What is the difference between using ~>~ and ~>>~ when redirecting output?
    #+begin_quote
    ~>~ overwrites a file; ~>>~ appends to a file.
    #+end_quote

11. What command would you use to *list all CSV files* in a relative
    path like ~../data/~?
    #+begin_quote
    ~ls ../data/*.csv~
    #+end_quote

12. What Unix command can you use to *remove carriage return characters*
    (~\r~) from output?
    #+begin_quote
    ~tr -d '\r'~
    #+end_quote


** DONE Finish "Data science on the command-line"

** TODO First presentation!
#+attr_html: :width 400px :float nil:
#+caption: C Del Gobbo (SCARF, 2025)
[[../img/delgobbo2.png]]

- Everyone has 10 minutes speaking time + 5 minutes discussion.
- That's not very much & you need to rehearse well to make it.
- Please prepare a question or comment for the discussion.
- At the end, I'll invite comments for improvement.

** TODO Optimizing code with C++ and Rcpp (quick demo)

- Rcpp is an R wrapper package for C++.
- It makes R much faster re: computations.
- It doesn't help much with regard to memory.
- We compare R, C++, and Python.

Download [[https://tinyurl.com/rcpp-codealong][tinyurl.com/rcpp-codealong]]
